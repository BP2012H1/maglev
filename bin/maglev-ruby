#!/bin/bash
#
# Runs a ruby file using the MagLev VM
COMMAND="`basename $0`"

usage()
{
cat << EOF
Usage: $COMMAND [options] [--] filename [script-args]

    Execute a Ruby file

    Currently, the filename argument is required.

OPTIONS:
   --copyright    Print copyright and exit
   -d, --debug    Set debugging flags
   -G             Use /opt/gemstone instead of MAGLEV_HOME for locks and logs
   -h             Show this message and exit
   --help         Show this message and exit
   -M<opt>        Pass a maglev option to the VM.  This flag may be passed multiple
                  times.  The currently recognized options are:
                    traceLoad     Trace loading of ruby files
                    logSexp       Print sexpressions as they are parsed
   --stone <name> Run script connecting to the named stone
   -v, --verbose  Print version number, then turn on verbose mode
   --version      Print version number and exit

MagLev will also read the MAGLEV_OPTS environment variable for options.
EOF
}

# Prepend the maglev options onto the passed parameters so we can parse
# them all the same in one pass
set -- $MAGLEV_OPTS $@

# Make sure MAGLEV_HOME is set
if [ -z "${MAGLEV_HOME}" ]; then
    echo "\$MAGLEV_HOME is not set."
    echo "To fix this, set a valid MAGLEV_HOME in your .bashrc"
    exit 1
fi
# Make sure GEMSTONE is set
if [ -z "${GEMSTONE}" ]; then
    export GEMSTONE=$MAGLEV_HOME/gemstone
    # echo "Setting \$GEMSTONE to \$MAGLEV_HOME/gemstone"
fi
# Check for topaz command to validate the $GEMSTONE directory
if [ ! -x $GEMSTONE/bin/topaz ]; then
    echo "$GEMSTONE does not appear to be a valid GemStone product directory"
    echo "To fix this, set a valid GEMSTONE in your .bashrc"
    exit 1
fi

conf_file=$MAGLEV_HOME/etc/system.conf
stone=gs64stone
args=""
debug=0
maglev_options=""
while [[ $# > 0 ]]
do
    case "$1" in
        --stone)
            stone=$2
            stone_conf=$MAGLEV_HOME/etc/stones/${stone}.conf
            if [[ -f $stone_conf ]]
            then
              conf_file=$stone_conf
            else
              echo "Couldn't find $stone_conf"
              exit 2
            fi
            shift
            ;;
        --copyright)
            echo "maglev - Copyright (C) 2008-2009 GemStone Systems, Inc."
            exit
            ;;
        -d|--debug)
            debug=1
            ;;
        -e)
            echo "-e not yet implemented"
            exit
            ;;
        -G)
            unset GEMSTONE_GLOBAL_DIR
            ;;
        -h|--help)
            usage
            exit
            ;;
        -I)
            args="$args '$1' '$2'"
            shift
            ;;
        -I*)
            args="$args '$1'"
            ;;
        -M*)
            maglev_options="$maglev_options ${1:2}"
            ;;
        -v|--verbose)
            grep ^maglev $MAGLEV_HOME/version.txt
            if [ $# -eq 1 ]; then exit; fi
            ;;
        --version)
            grep ^maglev $MAGLEV_HOME/version.txt
            exit
            ;;
        -w)
            # -w doesn't do anything at present
            # but maglev-ruby is invoked with -w by some test apps
            warning=1
            ;;

        --)
            break
            ;;
        -*)
            echo
            echo "Unrecognized option: $1"
            echo
            usage
            exit
            ;;
        *)
            break
            ;;
    esac
    shift
done

# Environment variable settings
export GEMSTONE_GLOBAL_DIR=$MAGLEV_HOME
export GEMSTONE_SYS_CONF=$conf_file


# Make sure we have at least one argument
if [ $# -lt 1 ]; then
  stdinscript=`mktemp /tmp/${COMMAND}.XXXX` || exit 1
  cat /dev/stdin > $stdinscript
  RUBYSCRIPT=$stdinscript
else
  RUBYSCRIPT=$1
  shift
fi

# Make sure the argument is a valid file
if [ ! -e $RUBYSCRIPT ]; then
    echo "$COMMAND: Error -- The file \"$RUBYSCRIPT\" does not exist"
    exit 1
fi

# The rest of the command line gets passed to $RUBYSCRIPT via ARGV.
# wrap each of the remaining command line params in single quotes so that
# we can pass them as a literal array to Smalltalk.
while [[ $# > 0 ]]
do
    args="$args '$1'"
    shift
done

# need to keep topaz's stdin connected to the tty always
#  so stdin is usable from Ruby , so do not redirect topaz stdin
dbscript=`mktemp /tmp/${COMMAND}.XXXX` || exit 1
trap "rm -f $dbscript $stdinscript" EXIT

rm -f $dbscript
if [ $debug == 1 ]; then
  cat $MAGLEV_HOME/etc/.topazdebugini > $dbscript
else
  cat $MAGLEV_HOME/etc/.topazini > $dbscript
fi

cat - >> $dbscript <<-EOFA
set gemstone $stone
login
run
| res ctx |
(ctx := RubyContext load: #($maglev_options) ) .
ctx runFileNamed: '$RUBYSCRIPT' withARGV: #($args) .
GsFile stdout close . "ensure final LF on stdout"
^ res
%
EOFA

# generate a topaz exit command as last line of init file
if [ $debug == 0 ]; then
  cat - >> $dbscript <<-EOFB
exit
EOFB
else
  cat - >> $dbscript <<-EOFC
exitifnoerror
EOFC
fi

TOPAZ_CMD="$GEMSTONE/bin/topaz -l -q -I $dbscript "

# note that   /usr/bin/which   on Solaris always produces  $?==0 , so be careful
#  about how you test result of which .
#
rlwrapExe=$(which rlwrap 2> /dev/null )
if [ -f "$rlwrapExe" ]; then
  $rlwrapExe $TOPAZ_CMD
  exitStatus=$?
else
  $TOPAZ_CMD
  exitStatus=$?
fi

exit $exitStatus
