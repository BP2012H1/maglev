#!/bin/bash
#
# Runs the equivalent of "maglev ruby"
COMMAND="`basename $0`"

usage()
{
cat << EOF
Usage: $COMMAND [options] <filename>

    Execute a Ruby file

OPTIONS:
   -d      Run in debugging mode
   -h      Show this message
   -V      Print version number and exit
   -v      Verbose.  Print version number, then handle rest of params.
EOF
}

# Make sure MAGLEV_HOME is set
if [ -z "${MAGLEV_HOME}" ]; then
    echo "\$MAGLEV_HOME is not set."
    echo "To fix this, set a valid MAGLEV_HOME in your .bashrc"
    exit 1
fi
# Make sure GEMSTONE is set
if [ -z "${GEMSTONE}" ]; then
    export GEMSTONE=$MAGLEV_HOME/gemstone
    # echo "Setting \$GEMSTONE to \$MAGLEV_HOME/gemstone"
fi
# Check for topaz command to validate the $GEMSTONE directory
if [ ! -x $GEMSTONE/bin/topaz ]; then
    echo "$GEMSTONE does not appear to be a valid GemStone product directory"
    echo "To fix this, set a valid GEMSTONE in your .bashrc"
    exit 1
fi

# Environment variable settings
export GEMSTONE_GLOBAL_DIR=$MAGLEV_HOME
export GEMSTONE_SYS_CONF=$MAGLEV_HOME/etc/system.conf
export TOPAZ_CMD="$GEMSTONE/bin/topaz -q -I $MAGLEV_HOME/etc/.topazini -l "

while [[ $# > 0 ]]
do
    case $1 in
        -d)
            debug=1
            ;;
        -h)
            usage
            exit
            ;;
        -V)
            grep GEMSTONE $GEMSTONE/version.txt
            exit
            ;;
        -v|--verbose)
            grep GEMSTONE $GEMSTONE/version.txt
            ;;
        *)
            break
            ;;
    esac
    shift
done

# Make sure we have one argument
if [ $# -lt 1 ]; then
    echo "Error: $COMMAND requires a filename."
    usage
    exit
    exit 1
fi

RUBYSCRIPT=$1
shift
# Make sure the argument is a valid file
if [ ! -e $RUBYSCRIPT ]; then
    echo "$COMMAND: Error: The file \"$RUBYSCRIPT\" does not exist"
    exit 1
fi

# The rest of the command line gets passed to $RUBYSCRIPT via ARGV.
# wrap each of the remaining command line params in single quotes so that
# we can pass them as a literal array to Smalltalk.
args=""
while [[ $# > 0 ]]
do
    args="$args '$1'"
    shift
done

# Finally, execute the command
if [[ -z $debug ]]
then
    # Normal execution
    $TOPAZ_CMD <<-EOF
	run
	RubyContext load.
	RubyContext default setARGV: #($args) .
	RubyContext loadFileNamed: '$RUBYSCRIPT'.
	%
	exit
	EOF
else
    # Debug.
    # The key to debug is to keep topaz's stdin connected to the tty.
    # So, we create a topaz script with all the goodies, and use it
    # as the topaz ini file
    base=`basename $0`
    dbscript=`mktemp /tmp/${base}.XXXX` || exit 1
    rm -f $dbscript
    cat $MAGLEV_HOME/etc/.topazdebugini > $dbscript
    cat - >> $dbscript <<-EOF
	run
	RubyContext load.
	RubyContext default setARGV: #($args) .
	RubyContext loadFileNamed: '$RUBYSCRIPT'.
	%
	EOF
    # Now run topaz with our debug script, including all params passed to us
    $(which rlwrap) $GEMSTONE/bin/topaz -I $dbscript -l
    rm -f $dbscript
fi
echo  # topaz tends to not output a newline, which can mess up the shell prompt