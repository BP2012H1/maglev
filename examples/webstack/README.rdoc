-*- org -*-
* Example WEB Stack for MagLev

  This directory contains a sample web application and configuration files
  that implement a standard WEB stack for MagLev.

  The sample application is used to measure performance of various aspects
  of the web environment from serving static pages, to complex reads and
  complex reads and writes.

** Rakefile overview

   The examples in this directory (except those based on WEBrick) require
   starting an external HTTPd, and then connecting one or more
   appropriately configured Ruby VMs to the httpd.  So, in general, you'll
   need to have two terminals open and issue two rake commands.  E.g.,

     # Terminal 1: start 1 httpd server, configured to listen to 2 SCGI
     # servers.
     $ rake lighttpd:scgi[2]

     # Terminal 2: start 2 MagLev SCGI servers
     $ rake scgi:maglev[2]

   And then you can hit the base url: http://localhost:3333/app/

   The recipe is:
   1. Figure out which httpd you want (e.g., lighttpd)
   2. Figure out which httpd <-> ruby protocol you want (e.g., scgi)
   3. Figure out how many ruby VMs you want running (e.g., 4)

   Then issue the following rake tasks:

   1. Start httpd using protocol and number:  <tt>rake lighttpd:scgi[4]</tt>
   2. Start number of Ruby VMs on protocol:   <tt>rake scgi:maglev[4]</tt>

** Parts of the Web Stack

   The parts of the Web Stack we consider are HTTP server, and the
   connection protocol between the HTTP server and the MagLev VM running
   Ruby.  We assume that all of the Web App frameworks of interest
   integrate with Rack, so we will limit our connection protocol survey to
   Rack adapters.

   + Front end load balancers etc.

   + HTTP servers (handle static files, and routing to WebApps)
   + Protocol to Web App (CGI, FastCGI, SCGI, HTTP, etc.)

   + Rack (handles other end of protocol)
   + Web App and Framework

*** Options

    Each subsection describes a particular HTTP to MagLev connection
    strategy, describes how to configure it and discusses some pros and cons
    for that strategy.

**** Protocol Options: HTTP <-> WebAppServer
     + HTTP
     + SCGI
     + FastCGI
     + CGI
     + LSAPI

**** HTTP Server Options
     List of HTTP Servers
     + WEBrick
     + Apache
     + nginx
     + lighttpd
     + LiteSpeed
     + Rainbows!
     + Unicorn

** Note on C-Extensions

   Many of the currently popular web components used in a Ruby deployment,
   are based on Ruby C-Extension interfaces to an underlying fast C
   implementation (Mongrel/Thin's HTTP parser, EventMachine, etc.).
   Currently, MagLev does not support C-Extensions, so those components are
   not available for use by MagLev.

   We are investigating what it would take to implement C-Extensions in
   MagLev, so this limitation may be temporary.  If and when we implement
   C-Extensions, we will update this investigation with details on using
   the newly available components.

** Protocols

   We first look at protocols that MagLev can support, and then we look at
   how to configure and hook-in various front-end HTTP servers.  Many of
   the popular protocols are either implemented

*** HTTP
**** Description

    Mongrel and Thin (RxINC: others?) use this approach, partly because it
    is a well known protocol (i.e., *all* HTTP servers already speak it,
    and most of them can reverse-proxy to the back end App Servers).

    The advantage that Mongrel, and its derivatives, bring, is a fast HTTP
    parser written in C.  The parser is a Ruby C-Extension, so it is
    integrated into the running Ruby VM.

    Currently, MagLev does not support C-Extensions, so MagLev must use a
    pure Ruby HTTP parser (i.e., WEBrick).
**** Install and Configuration
**** Discussion
*** SCGI
**** Description
     SCGI is an alternative to FastCGI or CGI.  See
     http://en.wikipedia.org/wiki/Simple_Common_Gateway_Interface

     The +scgi+ gem is a pure ruby implementation of an SCGI Rack Handler,
     and works with MagLev.

***** Install and Configuration

      1. Install the +scgi+ gem (one time):
           $ maglev-gem install scgi

      2. You'll need to configure your HTTP server to connect to the MagLev VM(s)
         running SCGI.  Each HTTP server has its own way of configuring.  For an
         example of a lighttpd configuration file, see
         <tt>config/lighttpd-scgi-1.conf</tt>.

      3. Start your HTTP server
           $ rake lighttpd:scgi

      4. Start your MagLev VM(s): you'll need to do this in a different terminal
         than the one your HTTP server is running in:
           $ rake scgi:maglev

      5. Connect to the web app: http://localhost:3333/app/login

***** Discussion

      On the plus side, SCGI is easy to setup and is reasonably snappy.  The SCGI gem does not support
      Unix domain sockets.

      + <tt>TIME_WAIT</tt> problem: the SCGI protocol indicates the end of
        a response by closing the connection (<tt>Rack::Handler::SCGI</tt>
        closes the connection from the HTTP Server).  The connection is
        TCP, so this can leave a lot of sockets in <tt>TIME_WAIT</tt>, and
        you may run out of sockets for a while if you have a lot of
        requests.
      + Concurrent Connection limits: The SCGI gem creates a +TCPServer+
        socket on a particular port (ports 300-3004, in the example config
        files).  The HTTP server connects to that port when it has an HTTP
        request for Ruby to handle.  The default configuration for the
        listen backlog on the +TCPServer+ socket is rather low, and the
        system does not degrade nicely if that limit is exceeded.

        TBD: Need to figure out how to increase the limit (basically, need
        to call Socket#listen(backlog) to increase it, but currently a bug
        ([[https://magtrac.gemstone.com/ticket/804][Trac 804]]) in MagLev does not allow setting the backlog.

*** TODO FastCGI
**** Description
**** Install and Configuration
**** Discussion
*** TODO CGI
**** Description
**** Install and Configuration
**** Discussion
*** TODO LSAPI
**** Description
**** Install and Configuration
**** Discussion

*** X
**** Not Considered
***** Mongrel (evented, swiftiplied)

      We did not consider Mongrel, as it is based on a Ruby C-extension to
      implement the HTTP parser.

      The idea behind Mongrel is to use the standard HTTP protocol between
      the Ruby process and the front end web server / load balancers /
      what-have-you.  This makes it easy to plug ruby VMs into many
      different web serving environments.  To make things fast, Mongrel
      implements the HTTP parser as a Ruby C-extension, and then calls into
      the Ruby VM once the request is "cooked".  Mongrel creates a thread
      per request, so there is the possibility for multi-threaded web
      processing, depending on whether the web framework grabs the GIL or
      not.

***** Thin: Mongrel HTTP Parser + EventMachine + Rack

      http://code.macournoyer.com/thin/

      Thin uses the Mongrel front-end HTTP parser, and then uses
      EventMachine to process the requests.  Both the Mongrel HTTP parser
      and EventMachine are based on Ruby C-extensions, so we do not consider
      them.

***** Passenger (mod_rack for Apache/nginx)

      http://www.modrails.com/index.html

      Passenger uses a C-extension.


***** LSAPI LiteSpeed Web Server (lsws)

**** WEBrick
***** Description
***** Configuration
***** Pros / Cons

**** Not Considered
     + EventMachine based solutions were not considered, since MagLev does
       not support Ruby C-extensions.

** TODO

   1. The transaction wrapper is committing on too many requests:
      + get /login and other non modifying pages
      + get /magtag.css, get /favicon.ico  (which should really be served by
        the front-end HTTP server, and not dealt with by Sinatra).

** Sample Application

   The sample application is a twitter clone.  The next iteration will add
   tagging.

*** TODO Write a MySQL version of the App
*** TODO Use a job queue to post tweets etc?
** Things to test

   1. Compare maglev performance with txn wrapper on static page, /magtag.css,
      without txn_wrapper to see what the txn wrapper overhead is.

** Notes
   + ab on Mac does not like "localhost", use "127.0.0.1" instead.
