= Overview


    XXXXXXXXX overall: scgi has the TCP TIME_WAIT issue, so avoid if possible

This directory contains examples of running WebApplications with MagLev
using various configurations of HTTPd and protocols to talk between MagLev
and the front-end HTTP server.

sample web application and configuration files
that implement a standard WEB stack for MagLev.

The sample application is used to measure performance of various aspects of
the web environment from serving static pages, to complex reads and complex
reads and writes.

NOTE: Currently, MagLev does not support C-Extensions, hence does not
support some popular web technology like thin, eventmachine based servers
etc.  We are working on an implementation of C-extensions, and when that
implementation is done, we will update this directory with information on
some of the more modern HTTP solutions.  Until then, you can at least play
with getting a MagLev solution working using the currently supported
options.

== Quick Start

To run the basic twitter clone application on one instance of MagLev with
WEBrick, first commit the code to the MagLev repository, and then run the
app:

  $ rake maglev:commit
  $ rake webrick:maglev

  Then hit http://localhost:3333/app/


== Performance Overview

I got the following performance on my "laptop class" "server":

  |----------------------+-------|
  | Configuration        | Req/s |
  |----------------------+-------|
  | 1 WEBrick            |   441 |
  |----------------------+-------|
  |----------------------+-------|
  | Lighttpd + 1 SCGI    |   843 |
  | Lighttpd + 4 SCGI    |  1334 |
  |----------------------+-------|
  | Lighttpd + 1 FastCGI |   792 |
  | Lighttpd + 4 FastCGI |  1282 |
  |----------------------+-------|
  | Lighttpd + 1 WEBrick |   369 |
  | Lighttpd + 4 WEBrick |   661 |
  |----------------------+-------|
  |----------------------+-------|

These performance results shouldn't be taken too seriously.  The real test
will be to run a web app for many hours or days at continuous high load to
see how garbage collection, DB transactions, memory leaks (if any) etc. all
play into things.  Then, we will also have to look for cyclic patterns in
the output (e.g., perhaps we average X req/sec, but there is a clear cycle
going from 0 upto 10X and back to 0 and std dev is really large).

== Docs

<tt>docs/maglev_webstack.rdoc</tt> describes various alternatives to
getting MagLev working as a WebApplication server.  It discusses the
various options and configurations to get MagLev to talk SCGI, FCGI, HTTP
etc. to front end HTTP servers.

== Rakefile overview

The examples in this directory (except those based on WEBrick) require
starting an external HTTPd, and then connecting one or more appropriately
configured Ruby VMs to the httpd.  So, in general, you'll need to have two
terminals open and issue two rake commands.  E.g.,

  # Terminal 1: start 1 httpd server, configured to listen to 2 SCGI
  # servers.
  $ rake lighttpd:scgi[2]

  # Terminal 2: start 2 MagLev SCGI servers
  $ rake scgi:maglev[2]

And then you can hit the base url: http://localhost:3333/app/

The recipe is:
1. Figure out which httpd you want (e.g., lighttpd)
2. Figure out which httpd <-> ruby protocol you want (e.g., scgi)
3. Figure out how many ruby VMs you want running (e.g., 4)

Then issue the following rake tasks:

1. Start httpd using protocol and number:  <tt>rake lighttpd:scgi[4]</tt>
2. Start number of Ruby VMs on protocol:   <tt>rake scgi:maglev[4]</tt>


By default, all HTTP servers are started on port 3333, and all Ruby VMs are
started on ports 3000 - 3003.  These facts are used in the rake tasks that
start and kill processes.

Some targets:
1. rake kill:all     To kill an entire experiment (HTTPd and VMs)
2. rake kill:vms     To kill just the Ruby VMs on ports 3000-3003
3. rake kill:httpd   To kill just the HTTPd on port 3333

== Sample WebStacks

lighttpd <=> scgi <=> MagLev

