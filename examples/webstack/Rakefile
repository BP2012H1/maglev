require 'rake/testtask'
require 'rake/clean'

CLEAN.include('log/scgi-*.out', 'log/rack-*.pid')
CLOBBER.include('log')

task :default => :'maglev:magtag'

MAGLEV_HOME = ENV['MAGLEV_HOME']
MBIN        = MAGLEV_HOME + '/bin'
RACKUP_OPTS = "-Ilib --env production"

Rake::TestTask.new do |t|
  t.libs << "lib"
  t.libs << "test"
  t.test_files = FileList['test/magtag/test_user.rb',
                          'test/magtag/test_tweet.rb',
                          'test/test_magtag_app.rb',]
  #  t.test_files = FileList['test/test_user.rb']
  t.ruby_opts << '-rubygems'
  # t.verbose = true
end

directory 'log'

namespace :maglev do
  desc "Run the MagTag Web App"
  task :magtag do
    bail_if_rvm_hosing_environment
    sh "#{MBIN}/rackup #{RACKUP_OPTS} --port 3333 config/no_txn_wrapper.ru"
  end


  desc "Commit the code for the models to MagLev"
  task :commit do
    bail_if_rvm_hosing_environment
    sh "maglev-ruby -Mcommit lib/magtag/user.rb "
    sh "maglev-ruby -Mcommit lib/magtag/tweet.rb"
  end

end

namespace :mri do
  desc "Run the MagTag Web App"
  task :magtag do
    sh "rackup #{RACKUP_OPTS} --port 3333 config/no_txn_wrapper.ru"
  end
end

desc "Call scgi:kill! and lighttpd:kill!"
task :kill! => ['scgi:kill!', 'lighttpd:kill!']


# RVM sets GEM_PATH, and I don't run maglev under RVM, so I detect and bail
# if I accidentally run in an rvm-ified shell.
def bail_if_rvm_hosing_environment
  if ENV['rvm_path']
    puts "ERROR: Running maglev with RVM environment"
    exit 1
  end
end


# Waits until the number of sockets in TIME_WAIT is below threshold
def wait_for_TIME_WAIT_to_clear(threshold=20)
  while true
    count = `netstat -a inet -n|grep TIME_WAIT|wc -l`.to_i
    return if count < threshold
    puts "TIME_WAIT count: #{count}"
    sleep 1
  end
end

# Kill the pid contained in pid_file using signal (default 'TERM'), and
# remove pid_file if success.
def kill_from_pidfile(pid_file, signal='TERM')
  puts "====== kill_from_pidfile(#{pid_file}, #{signal})"
  begin
    raise "Couldn't read file: '#{pid_file}'" unless pid = File.readlines(pid_file)
    puts "kill_from_pidfile: kill -s #{signal} #{pid}"
    sh "kill -s #{signal} #{pid}"
    sh "kill -s #{CONT} #{pid}"  do |ok,res|
      # send sig continue in case it is asleep
      # ignore errors
    end
    rm_f pid_file
    return true
  rescue
    puts "Failed on file '#{pid_file}'  pid '#{pid}' (pid_file not removed)"
  end
  false
end
