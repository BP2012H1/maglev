== Simple Sinatra Blog App for MagLev

This is a very simple blog app that uses Maglev persistence.

=== Files

* README  This file
* blog.rb  The persistent, business classes for the app.  This code is run
  once only.
* blog_app.rb The Sinatra app
* dumpdb.rb  Script that prints the contents of the db to stdout (debugging)
* txn_wrapper.rb  Rack middleware used by <tt>blog_app.rb</tt> to wrap a
  transaction around each HTTP request.

=== To Run

The app is split into a persistent part, <tt>blog.rb</tt>, and the sinatra
driver app, <tt>blog_app.rb</tt>.  You need to load <tt>blog.rb</tt> once,
which will define and persist the classes needed for the app, and then run
<tt>blog_app.rb</tt> to fire up Sinatra:

  $ maglev-ruby blog.rb  # only needs to be done once for a repository

  $ maglev-ruby blog     # run everytime you want to start the app

Then hit http://localhost:4567/

=== Issues

* Need better separation of model helpers and business objects.  Some of
  the lightweight Ruby ORM solutions (DataMapper, Sequel) provide nice
  features needed by any app.  We need some help here.

=== TODO

TODO for the sinatra app

* Get persistence of sinatra and rack working (autoload persistence)
* Try using shotgun for dev time file reloading (or Rack::Reloader)
* Get sessions working
* Separate the MaglevModel ane work on it
* Get a migration for seeding basic data working
* Performance profiling
* Sort entries by date
* Get partials implmented (rendering urls for tags and posts)

=== Discussion

In the first iteration of the blog app, Posts had an id field.  This is
legacy thinking from SQL...the reason blog posts have an id attribute is to
facilitate finding them in the DB.  But objects are already unique and have
a system managed __id__.  But there is a deeper problem with managing an id
field: How do you coordinate the id across multiple threads/VMs?  The
original code looked like:


    class Post
      def self.new(params)
        p = allocate
        p.initialize(new_id, params)
        add(p)
        p
      end

      def self.new_id
        # This is a concurrency conflict waiting to happen....
        Maglev.persistent { @id += 1 }
      end

      ...

    end

Since there is only one instance of the Post class in the repository, if
two VMs try to update the class instance variable <tt>@id</tt>, one will
commit first, and the other will have to deal with a failed commit.  But
each VM has unique  post objects with different <tt>__id__</tt>'s (because
the VM does do the hard work of ensuring globally unique ids for objects.


=== Credits

The layout is http://css4free.com/wp-content/uploads/templates/zineprint/
