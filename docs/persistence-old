== MagLev Persistence

To persist an object in MagLev, two conditions need to apply:
1. The object must be reachable from a persistent root
2. The state of the local VM must be committed to the MagLev Repository.

=== Reachable from a persistent root

To achieve #1, make sure your object is stored in a global variable, or
reachable starting from a global variable -- e.g., from the hat trick,

   class Hat
     ...
   end

   $hat = Hat.new

==== Commit the session state to the Repository

All changes to objects, classes, methods etc are local to your current
session (VM).  In order to persist them to the MagLev Repository,
you need to commit them.  To do that, you need to wrap your changes in a
transaction.  The <tt>Gemstone</tt> and <tt>RubyContext</tt> classes
provide the necessary hooks.

==== Wrap in a transaction

To wrap changes in a transaction:

    $foo = Object.new
    Maglev.commit_transaction

Then, from another session, you should be able to see $foo.

==== Committing new and modified classes

There is an additional step necessary if you modify a class method, or if
you add a new class to the system.  When you add/modify a class, the
methods for that class are stored in a session method dictionary (visible
only to the local session/VM).  To make those methods globally available,
you need to save the local state to the global space, and then commit.

=== Hat Trick Example

You can follow along below, or run the canned ruby scripts
create_hat.rb, add_rabbit_to_hat.rb, and show_hat_contents.rb
as shown in <tt>examples/hat_trick/README</tt>

Here is the hat trick example.  The Magician (VM one), creates an empty
hat.  The Magician shows that it is empty, then waves his magic wand and
pulls a rabbit out of the hat.

The magic happens due to the Assistant (second VM), which loads a Rabbit
class, creates a rabbit and stuffs it into the hat, so the Magician can
amaze the crowd.

We'll explain the trick at two levels.  In the first explanation, we show
all the steps necessary using the base APIs MagLev provides.  There are
several details to keep track of at this level. The second walk through
will use a higher level API that manages some of the details for us.

==== The Code
But first, the code.   The code used in both versions is in
<tt>examples/hat_trick</tt>.  The Hat is just a container that you can put
an item into and pull an item out of:

    class Hat
      def initialize
        @contents = []
      end

      def put(item)
        @contents << item
        nil
      end

      def contents
        @contents
      end
    end

The Rabbit class defines a cute, furry object to pull out of a hat:

    class Rabbit
      def inspect
        "\n () ()\n( '.' )\n(\")_(\")\n"
      end
    end

==== Low Level API version

Here is the detailed, low level API explanation of the hat trick.

The Magician creates a hat, and shows the audience that it is empty:

    MAGICIAN:

    $ cd examples/hat_trick/
    $ maglev-irb
    *> load 'hat.rb'                # hat.rb loaded into Magician VM only
    => true
    *> $hat = Hat.new               # Create our hat in a persistent root
    => #<Hat:0x1fcf9101>
    *> $hat.contents[0]             # Show everyone the hat is empty
    => nil

At this point, <tt>$hat</tt> and the code in <tt>hat.rb</tt> exist only in
the Magician's VM.  When we commit the transaction, both will be available
to all VMs attached to the Repository.

    *> RubyContext.save_context     # Stage hat code for commit
    => #<RubyContext:0x2437c501>
    *> Maglev.commit_transaction   # Commit code and hat to Repository
    => true
    *>

Now we switch to the Assistant's VM, and secretly put the rabbit in the
hat.

    ASSISTANT:

    $ cd examples/hat_trick/
    $ maglev-irb
    *> Maglev.abort_transaction   # Ensure we have a fresh view of Repository
    => Gemstone
    *> RubyContext.load_context    # Load changed code into working copy
    => #<RubyContext:0x2437c501>   # NOTE: same obj id as in Magician VM!
    *> $hat.contents[0]            # Check we have the hat, and it is empty
    => nil
    *> load 'rabbit.rb'            # Load rabbit code into Assistant VM
    => true
    *> $hat.put(Rabbit.new)        # Stuff a rabbit in the hat
    => nil
    *> RubyContext.save_context    # Stage rabbit code for commit
    => #<RubyContext:0x2437c501>
    *> Maglev.commit_transaction  # Commit rabbit code and rabbit in hat
    => true

The Assistant starts by aborting the current transaction and then loading
the ruby context.  This is only necessary if the Assistant VM was started
before the Magician did the commit.  The <tt>Maglev.abort_transaction</tt>
flushes any changes in the current VM (in our case, none), and then
refreshes state from the Repository (i.e., gets <tt>$hat</tt> and updates
the RubyContext with the hat code).  Since the VM runs off of the working
copy of the ruby code, we then have to move the hat.rb code into the
working copy, which is done with the <tt>RubyContext.load_context</tt>.  If
the Assistant VM is started after the Magician commits, then neither the
abort nor the load is necessary, since the VM initialized everything from
the committed view of the Repository.

After getting the signal from the Assistant that the rabbit is loaded, the
Magician waves his magic wand and pulls the rabbit out of the hat:

Wave magic wand:

    MAGICIAN:

    *> Maglev.abort_transaction     # Refresh our view from the Repository
    => Gemstone                      # (reads $hat, that now has a rabbit)
    *> RubyContext.load_context      # Copy persistent view of code to working view
    => #<RubyContext:0x2437c501>

Amaze the crowd:

    MAGICIAN:

    *> $hat.contents[0]
    =>
     () ()
    ( '.' )
    (")_(")


==== A Higher Level API version

Here is a different run of the hat trick.  This time, we use an
experimental higher level API that assumes we want to manage both code and
data at each of the life-cycle stages.  The file with the experimental code
is <tt>lib/ruby/1.8/maglev.rb</tt>.

The Magician creates a hat, and shows the audience that it is empty:

    MAGICIAN:

    $ cd examples/hat_trick/
    $ maglev-irb
    >> require 'maglev'                  # Load the helper library
    => true
    *> load 'hat.rb'                     # Load the hat code
    => true
    *> $hat = Hat.new                    # Create hat
    => #<Hat:0x05a8ea01>
    *> $hat.contents[0]                  # The hat is empty
    => nil
    *> Maglev::CodeAndData.commit_txn    # Stage the new code (both hat and
    => true                              # maglev are staged) and commit code
    *>                                   # and data.

Now the Assistent does some work:

    ASSISTANT:

    $ cd examples/hat_trick/
    $ maglev-irb
    >> Maglev::CodeAndData.freshen       # No need to load maglev, if assitant
    => true                              # started after Magician commits.
    *> $hat.contents[0]                  # Hat is there, but empty
    => nil
    *> load 'rabbit.rb'                  # Load rabbit code
    => true
    *> $hat.put(Rabbit.new)              # Stuff rabbit in hat
    => nil
    *> Maglev::CodeAndData.commit_txn    # Commit both rabbit code and rabbit
    => true

Back in the Magician:

    *> Maglev::CodeAndData.freshen       # Wave magic wand (loads both the
    => true                              # rabbit and its code)
    *> $hat.contents[0]                  # Pull rabbit out of hat
    =>
     () ()
    ( '.' )
    (")_(")
