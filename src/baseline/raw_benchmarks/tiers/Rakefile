# Automate turning "tiers" benchmark results into a .csv spreadsheet
# Usage: rake YAML_DIR=runs/2010-01-23/ BASELINE=ruby-1.8.6-p383

BASEDIR           = File.expand_path(File.dirname(__FILE__))
YAML_DIR          = ENV['YAML_DIR'] || BASEDIR 
OUTPUT_DIR        = ENV['OUTPUT_DIR'] || BASEDIR + "/results"
BASELINE          = ENV['BASELINE'] || "ruby-1.8.6-p383"
# Normalize time or speed. time: lower numbers better, speed: higher numbers better. 
NORMALIZE         = ENV['NORMALIZE'] || "time"

task :default => :to_csv

desc "Generate a CSV file of benchmark results"
task :to_csv => :setup do
  require 'yaml'

  os = `uname`.chomp
  host = `uname -n`.chomp
  # ident = "#{os}-#{Time.now.strftime "%y%m%d"}"
  ident = "#{os}-#{host}-#{Time.now.strftime "%y%m%d.%H%M"}"
  needs_header = true
  row = 0
  first_data_row = 0
  last_data_row = 0
  last_data_column = 0
  number_of_impls = 0
  heads = []
  tails = []
  baseline_column = ""
  cell = ""

  puts "Creating Tiers Benchmark spreadsheet"
  csv_report = "#{OUTPUT_DIR}/Tiers-#{ident}.csv"
  puts "  Writing spreadsheet to #{csv_report}"

  File.open csv_report, "w" do |outfile|
  row += 1; outfile.puts "Benchmarks from #{ident}\n"
  row += 1; outfile.puts
    Dir[YAML_DIR + "/**/*.yaml"].sort.each do |ymlfile|
      puts "  Processing #{ymlfile}"
      File.open ymlfile, "r" do |file|
        YAML.load_documents file do |doc|
          doc.each do |benchmark|
            benchfile = benchmark['file']
            benchruns = benchmark['runs']
            # Print header row
            if needs_header
              number_of_impls = benchruns.keys.size
              row += 1
              first_data_row = row + 1
              heads << first_data_row
              outfile.print "Benchmark File,"
              outfile.print benchruns.keys.sort.join(",")
              outfile.print ",,Fastest,Slowest,,"
              outfile.puts benchruns.keys.sort.join(",")
              # compute column of BASELINE
              baseline_column = ""
              idx = benchruns.keys.sort.index(BASELINE)
              if idx.nil?
                puts "ERROR: Can't find Ruby named #{BASELINE}"
                puts "BASELINE= should be one of: " + benchruns.keys.sort.join(" ")
                exit 1
              else
                baseline_column << (65 + idx + 1)
              end
              needs_header = false
            end
            # Print data row
            row += 1
            last_data_column = 65 + benchruns.keys.size # Columns are ASCII Chars
            range = "B#{row}:"
            range << (last_data_column) << "#{row}"
            outfile.print "#{benchfile}"
            # Print raw median times
            benchruns.keys.sort.each do |impl|
              median = benchruns[impl]['median']
              outfile.print ",#{median}"
            end
            # Print min and max times
            outfile.print ",,=MIN(#{range}),=MAX(#{range}),"
            # Print normalized times
            1.upto(number_of_impls) do |n|
              compare_column = 65 + n
              cell = ""
              if NORMALIZE == "time"
                cell << "#{baseline_column}#{row}/" << (compare_column) << "#{row}"
              else
                cell << (compare_column) << "#{row}/#{baseline_column}#{row}"
              end
              outfile.print ",=$#{cell}"
            end
            outfile.puts
          end
        end
        # Fill in formula for Geometric Mean
        last_data_row = row
        tails << last_data_row
        row += 1
        outfile.print "Geometric Mean normalized against #{BASELINE}"
        1.upto(number_of_impls+4) { |n| outfile.print ","}
        1.upto(number_of_impls) do |n|
          current_column = 65 + n + number_of_impls + 4
          cell = ""
          cell << current_column << "#{first_data_row}:" << current_column << "#{last_data_row}"
          outfile.print ",=GEOMEAN(#{cell})"
        end
        outfile.puts
        row += 1; outfile.puts
        needs_header = true
      end
    end
    row += 1
    outfile.print "Overall Geometric Mean normalized against #{BASELINE}"
    1.upto(number_of_impls+4) { |n| outfile.print ","}
    1.upto(number_of_impls) do |n|
      current_column = 65 + n + number_of_impls + 4
      cell = ""
      0.upto(heads.size - 1) do |m|
        cell << current_column << "#{heads[m]}:" << current_column << "#{tails[m]}"
        cell << ";" unless m == (heads.size - 1)
      end
      outfile.print ",=GEOMEAN(#{cell})"
    end
    outfile.puts
  end
  puts "Done"
end
  
# Creates directories for results
task :setup do
  mkdir_p OUTPUT_DIR, :verbose => $verbose
end
