require File.expand_path('simple', File.dirname(__FILE__))

require 'zlib'
require 'stringio'

data_dir     = File.dirname(__FILE__) + '/test_data'
plain_text   = File.read(data_dir + '/zlib_test_file')
mri_deflated = File.read(data_dir + '/zlib_test_file.dflated')

# ####################################################################
#    Zlib::Deflate tests
# ####################################################################
#deflated_text = Zlib::Deflate.deflate(plain_text)

# This was used one time by MRI to create the test file.  The
# Deflate/Inflate work w/o the gzip header
#
# File.open(data_dir + '/zlib_test_file.dflated', "w") do |f|
#   f << deflated_text
# end

# ####################################################################
#    Zlib::Inflate tests
# ####################################################################
test(Zlib::Inflate.inflate(mri_deflated), plain_text, 'Zlib::Inflate.inflate')

# ####################################################################
#    Zlib::Gzip* tests
# ####################################################################
# Write a gzip file of data
def zip(data, file)
  f = File.open(file, 'w+')
  gz_writer = Zlib::GzipWriter.new(f)
  gz_writer.orig_name=('test.i')
  gz_writer.write(data)
  gz_writer.close
  # MRI GzipWriter closes f TOOD: test f is closed...
end

# Read a gzip file and return the contents
def unzip(file)
  new_data = ''
  f = File.open(file, 'r')
  gz_reader = Zlib::GzipReader.new(f)
  new_data = gz_reader.read
  gz_reader.close
  new_data
  # MRI GzipReader closes f TOOD: test f is closed...
end

# A simple round-trip test through the file system
original = "Some test data."
filename = 'test.gz'

zip(original, filename)
copy = unzip(filename)

test(copy, original, 'Round trip')

# # Test that MagLev can read a gzip file generated by MRI
r = unzip(data_dir + '/test-mri.gz')
test(r, original, "Unzip of MRI file")

# some_data = "Here is some data      with         spaces"
# zipper = Zlib::Deflate.new
# compressed = zipper.deflate(some_data, Zlib::FINISH)

# unzipper = Zlib::Inflate.new
# unzipper << compressed
# processed_data = unzipper.inflate(nil)
# puts "original:       #{some_data}"
# puts "processed_data: #{processed_data}"
# raise "Failed round trip" unless processed_data == some_data


# # Test unzipping a third-party generated file that is big enough to expose
# # buffering problems
# data = unzip(data_dir + '/latest_specs.4.8.gz')
# puts "data length: #{data.length}"

# # A test using a file created by the Mac OS X gzip utility.

# data_dir = File.dirname(__FILE__) + '/test_data'
# orig_file = data_dir  + '/zlib_test_file'
# gz_file   = orig_file + '.gz'
# orig_data = File.read(orig_file)
# File.open(gz_file) do |f|
#   gzip = Zlib::GzipReader.new(f)
#   data = gzip.read
#   raise "Fail" unless data == orig_data
# end

# def deflate(a_string, level = Zlib::BEST_SPEED)
#   z = Zlib::Deflate.new(level)
#   compressed = z.deflate(a_string, Zlib::FINISH)
#   z.close
#   puts "deflate:  #{compressed.inspect}"
#   compressed
# end

# # Uncompress compressed_string and return it
# def inflate(compressed_string)
#   zstream = Zlib::Inflate.new
#   buf = zstream.inflate(compressed_string)
#   zstream.finish
#   zstream.close
#   puts "inflate:  #{buf.inspect}"
#   buf
# end

# original = "Hello Mom"
# compressed = deflate(original)
# uncompressed = inflate(compressed)
# raise "Not the same: original: #{original}  uncompressed: #{uncompressed}" unless uncompressed == original

#report
#true
