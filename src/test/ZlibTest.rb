require File.expand_path('simple', File.dirname(__FILE__))

require 'zlib'
require 'stringio'

data_dir     = File.dirname(__FILE__) + '/test_data'
plain_text   = File.read(data_dir + '/zlib_test_file')
mri_deflated = File.read(data_dir + '/zlib_test_file.dflated')

# ####################################################################
#    Zlib::Deflate tests
# ####################################################################
#deflated_text = Zlib::Deflate.deflate(plain_text)

# This was used one time by MRI to create the test file.  The
# Deflate/Inflate work w/o the gzip header
#
# File.open(data_dir + '/zlib_test_file.dflated', "w") do |f|
#   f << deflated_text
# end

# ####################################################################
#    Zlib::Inflate tests
# ####################################################################
test(Zlib::Inflate.inflate(mri_deflated), plain_text, 'Zlib::Inflate.inflate')

# ####################################################################
#    Zlib::Gzip* tests
# ####################################################################
# Write a gzip file of data
def zip(data, file)
  f = File.open(file, 'w+')
  gz_writer = Zlib::GzipWriter.new(f)
  gz_writer.orig_name=('test.i')
  gz_writer.write(data)
  gz_writer.close
  # MRI GzipWriter closes f TOOD: test f is closed...
end

# Read a gzip file and return the contents
def unzip(file)
  new_data = ''
  f = File.open(file, 'r')
  gz_reader = Zlib::GzipReader.new(f)
  new_data = gz_reader.read
  gz_reader.close
  new_data
  # MRI GzipReader closes f TOOD: test f is closed...
end

# A simple round-trip test through the file system
original = "Some test data."
filename = 'test.gz'

zip(original, filename)
copy = unzip(filename)

test(copy, original, 'Round trip')

# Test that MagLev can read a gzip file generated by MRI
r = unzip(data_dir + '/test-mri.gz')
test(r, original, "Unzip of MRI file")

File.delete(filename)

# ####################################################################
#    Other Tests
# ####################################################################

# Test that zlib will accept "IO" objects that are not derived from IO.
# RubyGems passes in a wrapper object.  This is important since
# CZstream>>_readAndDecompress used to call IO>>read:into:, but a non IO
# derived object won't have that.  This test ensures we go through the
# @ruby:read path.  Ditto the write path and IO>>write:from:.
class IODelegate
  def initialize(io)
    @real_io = io
  end
  def read(*args)
    @real_io.read(*args)
  end
  def write(*args)
    @real_io.write(*args)
  end
end

# Compress the data
sio = StringIO.new('', "r+")
dio = IODelegate.new(sio)
gz_writer = Zlib::GzipWriter.new(dio)

gz_writer.write(original)
gz_writer.close

# Uncompress the data
sio2 = StringIO.new(sio.string, "r")
dio2 = IODelegate.new(sio2)
gz_reader = Zlib::GzipReader.new(dio2)

new_data = gz_reader.read
gz_reader.close
test(new_data, original, 'Delegate')


# Bug test.  Writing data of specific lengths was broken.  The length
# varied depending on how much data was in the buffer already and what the
# half size of the buffer was.  So, we loop over a good number of sizes to
# trigger the buggy behavior (seems that when i is 65, it triggers).


# This test passes if no exception is raised.
sio = StringIO.new('', "r+")
dio = IODelegate.new(sio)
gz_writer = Zlib::GzipWriter.new(dio)

1.upto(2049) do |i|
  gz_writer.write("x"*i)
end
gz_writer.close

#####################
report
true
