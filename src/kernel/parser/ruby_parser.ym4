# -*- racc -*-

include(trace_macros.m4)

class MagRp::RubyParser

token kCLASS kMODULE kDEF kUNDEF kBEGIN kRESCUE kENSURE kEND kIF kUNLESS
      kTHEN kELSIF kELSE kCASE kWHEN kWHILE kUNTIL kFOR kBREAK kNEXT
      kREDO kRETRY kIN kDO kDO_COND kDO_BLOCK kRETURN kYIELD kSUPER
      kSELF kNIL kTRUE kFALSE kAND kOR kNOT kIF_MOD kUNLESS_MOD kWHILE_MOD
      kUNTIL_MOD kRESCUE_MOD kALIAS kDEFINED klBEGIN klEND k__LINE__
      k__FILE__ tIDENTIFIER tFID tGVAR tIVAR tCONSTANT tCVAR tNTH_REF
      tBACK_REF tSTRING_CONTENT tINTEGER tFLOAT tREGEXP_END tUPLUS
      tUMINUS tUMINUS_NUM tPOW tCMP tEQ tEQQ tNEQ tGEQ tLEQ tANDOP
      tOROP tMATCH tNMATCH tDOT tDOT2 tDOT3 tAREF tASET tLSHFT tRSHFT
      tCOLON2 tCOLON3 tOP_ASGN tASSOC tLPAREN tLPAREN2 tRPAREN tLPAREN_ARG
      tLBRACK tRBRACK tLBRACE tLBRACE_ARG tSTAR tSTAR2 tAMPER tAMPER2
      tTILDE tPERCENT tDIVIDE tPLUS tMINUS tLT tGT tPIPE tBANG tCARET
      tLCURLY tRCURLY tBACK_REF2 tSYMBEG tSTRING_BEG tXSTRING_BEG tREGEXP_BEG
      tWORDS_BEG tAWORDS_BEG tSTRING_DBEG tSTRING_DVAR tSTRING_END t_STRING
      tSYMBOL tNL tEH tCOLON tCOMMA tSPACE tSEMI tLBRACK_STR tLAST_TOKEN 

prechigh
  right    tBANG tTILDE tUPLUS
  right    tPOW
  right    tUMINUS_NUM tUMINUS
  left     tSTAR2 tDIVIDE tPERCENT
  left     tPLUS tMINUS
  left     tLSHFT tRSHFT
  left     tAMPER2
  left     tPIPE tCARET
  left     tGT tGEQ tLT tLEQ
  nonassoc tCMP tEQ tEQQ tNEQ tMATCH tNMATCH
  left     tANDOP
  left     tOROP
  nonassoc tDOT2 tDOT3
  right    tEH tCOLON
  left     kRESCUE_MOD
  right    tEQL tOP_ASGN
  nonassoc kDEFINED
  right    kNOT
  left     kOR kAND
  nonassoc kIF_MOD kUNLESS_MOD kWHILE_MOD kUNTIL_MOD
  nonassoc tLBRACE_ARG
  nonassoc tLOWEST
preclow

rule

         program:   {
		      yTrace( "program: " )
                      @lexer.lex_state=( Expr_beg )
                      result = val[vofs]
                    }
                    comp_stamt
                    {
		      yTrace( "program: comp_stamt")
                      result = val[vofs+ 1]
                    }

        body_stamt: comp_stamt opt_rescue opt_else opt_ensure
                    {
		      yTrace("body_stamt: comp_stamt ")
                      result = new_body( val, vofs)
                    }

        comp_stamt: sttmts opt_termms 
		    {
                      yTrace("comp_stamt: sttmts opt_termms")
                      result = new_compstamt(val[vofs])
                    }

           sttmts: none        Y_TRACE_val_vofs("sttmts: none")
                | stmt         Y_TRACE_val_vofs("sttmts: | stmt")
                | sttmts terms stmt
                    {
		      yTrace("sttmts: | sttmts terms stmt ")
                      result = self.block_append( val[vofs], val[vofs + 2])
                    }
                | error stmt
                    {
		      yTrace("sttmts: | error stmt")
                      result = val[vofs + 1]
                    }

            stmt: kALIAS fitem
                    {
		      yTrace("stmt: kALIAS fitem")
                      lx = @lexer
                      lx.lex_state=( Expr_fname )
                      result = -901 # lx.lineno_
                    }
                    fitem
                    {
		      yTrace("stmt: fitem")
                      result = RubyAliasNode.s(val[vofs + 1], val[vofs + 3])
                      result.src_offset=( val[vofs].src_offset ) # of kALIAS RpNameToken
                    }
                | kALIAS tGVAR tGVAR
                    {
		      yTrace("stmt: | kALIAS tGVAR tGVAR")
                      result = RubyGlobalVarAliasNode.s( val[vofs + 1].symval, val[vofs + 2].symval) # s(:valias)
                    }
                | kALIAS tGVAR tBACK_REF
                    {
		      yTrace("stmt: | kALIAS tGVAR tBACK_REF")
                      result = RubyGlobalVarAliasNode.s( val[vofs + 1].symval, :"$#{val[vofs + 2]}" )  # s(:valias)
                    }
                | kALIAS tGVAR tNTH_REF
                    {
		      yTrace("stmt: | kALIAS tGVAR tNTH_REF")
                      yyerror "can't make alias for the number variables"
                    }
                | kUNDEF undef_list
                    {
		      yTrace("stmt: | kUNDEF undef_list")
                      result = val[vofs + 1]
                    }
                | stmt kIF_MOD expr_value
                    {
		      yTrace("stmt: | stmt kIF_MOD expr_value")
                      result = new_if(val[vofs + 2], val[vofs ], nil ) 
                      result.src_offset=( val[vofs + 1].src_offset )
                    }
                | stmt kUNLESS_MOD expr_value
                    {
		      yTrace("stmt: | stmt kUNLESS_MOD expr_value")
                      result = new_if( val[vofs + 2], nil, val[vofs])
                      result.src_offset=( val[vofs + 1].src_offset )
                    }
                | stmt kWHILE_MOD expr_value
                    {
		      yTrace("stmt: | stmt kWHILE_MOD expr_value")  
                      # val_[1] is kWHILE_MOD RpNameToken
                      result = new_while( val[vofs ], val[vofs + 2] )
                      result.src_offset=( val[vofs + 1].src_offset) # kWHILE_MOD  RpNameToken
                    }
                | stmt kUNTIL_MOD expr_value
                    {
		      yTrace("stmt: | stmt kUNTIL_MOD expr_value")
                      # val_[1] is kUNTIL_MOD RpNameToken
                      result = new_until( val[vofs ], val[vofs + 2] )
                      result.src_offset=( val[vofs + 1].src_offset )
                    }
                | stmt kRESCUE_MOD stmt
                    {
		      yTrace("stmt: | stmt kRESCUE_MOD stmt")
                      # result = s(:rescue, val_[0], s(:resbody, s(:array), val_[2]))
                      resbody = RubyRescueBodyNode.s(nil, val[vofs + 2])
                      result = RubyRescueNode.s( val[vofs ], resbody, nil)
                      ofs = val[vofs + 1].src_offset  # kRESCUE position
                      result.src_offset=( ofs )
                      resbody.src_offset=( ofs )
                    }
                | klBEGIN
                    {
		      yTrace("stmt: | klBEGIN")
                      if (@in_def || @in_single > 0) then
                        raise SyntaxError , "BEGIN in method" 
                      end
                      @env.extend( false, nil)
                      result = val[vofs]
                    }
                    tLCURLY comp_stamt tRCURLY
                    {
		      yTrace("stmt: ___ tLCURLY comp_stamt tRCURLY")
                      # result = new_iter s(:preexe), nil, val[vofs + 3] # TODO: add test?
                      result = nil # TODO: since it isn't supposed to go in the AST
                    }
                | klEND tLCURLY comp_stamt tRCURLY
                    {
		      yTrace("stmt: | klEND tLCURLY comp_stamt tRCURLY")
                      if (@in_def || @in_single > 0) then
                        yyerror "END in method; use at_exit"
                      end
                      # result = new_iter s(:postexe), nil, val_[2]
                      result = new_iter(nil, val[vofs + 2])
                    }
                | lhs tEQL command_call
                    {
		      yTrace("stmt: | lhs tEQL command_call")
                      result = self.node_assign(val[vofs ], val[vofs + 2])
                    }
                | mLhs tEQL command_call
                    {
		      yTrace("stmt: | mLhs tEQL command_call")
                      result = masgn_append_arg( val[vofs ], val[vofs + 2] ) 
                    }
                | varLhs tOP_ASGN command_call
                    {
		      yTrace("stmt: | varLhs tOP_ASGN command_call")
                      result = new_op_asgn(val, vofs)
                    }
                | primary_value tLBRACK_STR aref__args tRBRACK tOP_ASGN command_call
                    {
		      yTrace("stmt: | primary_value tLBRACK_STR aref__args tRBRACK tOP_ASGN command_call")
                      result = RubyOpElementAsgnNode.s(val[vofs ], val[vofs + 2], val[vofs + 4], val[vofs + 5]) # s(:op_asgn1 )
                    }
                | primary_value tDOT tIDENTIFIER tOP_ASGN command_call
                    {
		      yTrace("stmt: | primary_value tDOT tIDENTIFIER tOP_ASGN command_call")
                      internal_error(":op_asgn never seen from MRI parser ")
                      # result = s(:op_asgn, val_[0], val_[4], val_[2], val_[3])
                      result = nil
                    }
                | primary_value tDOT tCONSTANT tOP_ASGN command_call
                    {
		      yTrace("stmt: | primary_value tDOT tCONSTANT tOP_ASGN command_call")
                      internal_error(":op_asgn never seen from MRI parser ")
		      # result = s(:op_asgn, val_[0], val_[4], val_[2], val_[3])
		      result = nil
		    } 
		  | primary_value tCOLON2 tIDENTIFIER tOP_ASGN command_call
		      {
		        yTrace("stmt: | primary_value tCOLON2 tIDENTIFIER tOP_ASGN command_call")
                        internal_error(":op_asgn never seen from MRI parser ")
			# result = s(:op_asgn, val_[0], val_[4], val_[2], val_[3])
                        result = nil
		      }
		  | backref tOP_ASGN command_call
		      {
			yTrace("stmt: | backref tOP_ASGN command_call")
                        v_zero = val[vofs ] 
			self.backref_assign_error( v_zero )
                        result = v_zero 
		      }
		  | lhs tEQL mrhs
		      {
			yTrace("stmt: | lhs tEQL mrhs")
			result = self.node_assign(val[vofs ], RubySValueNode.s( val[vofs + 2]))
		      }
		  | mLhs tEQL arg_value
		      {
			yTrace("stmt: | mLhs tEQL arg_value")
			result =  masgn_append_arg(val[vofs ], val[vofs + 2] )
		      }
		  | mLhs tEQL mrhs
		      {
			yTrace("stmt: | mLhs tEQL mrhs")
			result = masgn_append_mrhs( val[vofs ], val[vofs + 2] )
		      }
		  | expr            Y_TRACE_val_vofs("stmt: | expr")

	      expr: command_call    Y_TRACE_val_vofs("expr: command_call")
		  | expr kAND expr
		      {
			yTrace("expr: | expr kAND expr")
			result = logop( RubyAndNode,  val[vofs ], val[vofs + 2])  # s(:and )
		      }
		  | expr kOR expr
		      {
			yTrace("expr: | expr kOR expr")
			result = logop( RubyOrNode, val[vofs ], val[vofs + 2]) # s(:or )
		      }
		  | kNOT expr
		      {
			yTrace("expr: | kNOT expr")
			result = RubyNotNode.s( val[vofs + 1]) # s(:not )
		      }
		  | tBANG command_call
		      {
			yTrace("expr: | tBANG command_call")
			result = RubyNotNode.s( val[vofs + 1]) # s(:not )
		      }
		  | arg           Y_TRACE_val_vofs("expr: | arg")

	expr_value: expr
		      {
			yTrace("expr_value: expr")
			result = value_expr(val[vofs ])
		      }

      command_call: command           Y_TRACE_val_vofs("command_call: command")
		  | block_command     Y_TRACE_val_vofs("command_call: block_command")
		  | kRETURN call_args
		      {
			yTrace("command_call: kRETURN call_args")
                        result = RubyReturnNode.s( ret_args(val[vofs + 1]))
			result.src_offset=( val[vofs ].src_offset ) # of the kRETURN
		      }
		  | kBREAK call_args
		      {
			yTrace("command_call: | kBREAK call_args")
			# result = s(:break, ret_args(val_[1]))
                        result = RubyBreakNode.s( ret_args(val[vofs + 1]))
                        result.src_offset=( val[vofs ].src_offset ) #  of the kBREAK
		      }
		  | kNEXT call_args
		      {
			yTrace("command_call: | kNEXT call_args")
			# result = s(:next, ret_args(val_[1]))
                        result = RubyNextNode.s( ret_args(val[vofs + 1]))
                        result.src_offset=( val[vofs ].src_offset ) #  of the kNEXT
		      }

     block_command: block_call          Y_TRACE_val_vofs("block_command: block_call")
		  | block_call tDOT operation2 command_args
		      {
			yTrace("block_command: | block_call tDOT operation2 command_args")
			result = new_call(val[vofs ], val[vofs + 2], val[vofs + 3])
		      }
		  | block_call tCOLON2 operation2 command_args
		      {
			yTrace("block_command: | block_call tCOLON2 operation2 command_args")
			result = new_call(val[vofs ], val[vofs + 2], val[vofs + 3])
		      }

   cmd_brace_block: tLBRACE_ARG
		      {
			yTrace("cmd_brace_block: tLBRACE_ARG")
			@env.extend( true , nil) # (:dynamic)
                        @env.in_block_params=(true)
			result = -902 #  @lexer.lineno_
		      }
		      opt_block_var
		      {
			yTrace("cmd_brace_block: ___ opt_block_var")
                        @env.in_block_params=(false)
			result = @env.dynamic_keys
		      }
		      comp_stamt tRCURLY
		      {
			yTrace("cmd_brace_block: ___ comp_stamt tRCURLY")
			result = new_iter(val[vofs + 2], val[vofs + 4])
                      @env.unextend
                    }

         command: operation command_args =tLOWEST
                    {
		      yTrace("command: operation command_args =tLOWEST")
                      result = new_fcall( val[vofs ], val[vofs + 1])
                    }
                | operation command_args cmd_brace_block
                    {
		      yTrace("command: | operation command_args cmd_brace_block")
                      result = new_fcall( val[vofs ], val[vofs + 1])
                      v_two = val[vofs + 2]
                      if v_two then
                        if v_two.class._equal?(RubyBlockPassNode) # v_two[0] == :block_pass 
                          raise "both block arg and actual block given"
                        end
                        # result, operation = val_[2], result
                        # result.insert 1, operation
                        iter = v_two
                        call = result
                        iter.call=(call)
                        result = iter
                      end
                    }
                | primary_value tDOT operation2 command_args =tLOWEST
                    {
		      yTrace("command: | primary_value tDOT operation2 command_args =tLOWEST")
                      result = new_call(val[vofs ], val[vofs + 2], val[vofs + 3])
                    }
                | primary_value tDOT operation2 command_args cmd_brace_block
                    {
		      yTrace("command: | primary_value tDOT operation2 command_args cmd_brace_block")
                      result = new_call(val[vofs ], val[vofs + 2], val[vofs + 3])
                    }
                | primary_value tCOLON2 operation2 command_args =tLOWEST
                    {
		      yTrace("command: | primary_value tCOLON2 operation2 command_args =tLOWEST")
                      result = new_call(val[vofs], val[vofs + 2], val[vofs + 3])
                    }
                | primary_value tCOLON2 operation2 command_args cmd_brace_block
                    {
		      yTrace("command: | primary_value tCOLON2 operation2 command_args cmd_brace_block")
                      result = new_call(val[vofs ], val[vofs + 2], val[vofs + 3])
                      if val[vofs + 4] then
                        #if result[0] == :block_pass then # REFACTOR
                        if result.rcvr.class._equal?(RubyBlockPassNode) 
                          raise "both block arg and actual block given"
                        end
                        internal_error("dont know how to append to selector") 
                        val[vofs + 2] << result
                        result = val[vofs + 2]
                      end
                    }
                | kSUPER command_args
                    {
		      yTrace("command: | kSUPER command_args")
                      result = new_super( val, vofs )
                    }
                | kYIELD command_args
                    {
		      yTrace("command: | kYIELD command_args")
                      result = new_yield( val[vofs + 1] )
                      result.src_offset=( val[vofs ].src_offset ) # of the kYIELD
                    }

            mLhs: mlhs_basic         Y_TRACE_val_vofs("mLhs: mlhs_basic")
                | tLPAREN mlhs_entry tRPAREN
                    {
		      yTrace("mLhs: | tLPAREN mlhs_entry tRPAREN")
                      result = val[vofs + 1]
                    }

      mlhs_entry: mlhs_basic         Y_TRACE_val_vofs("mlhs_entry: mlhs_basic")
                | tLPAREN mlhs_entry tRPAREN
                    {
		      yTrace("mlhs_entry: | tLPAREN mlhs_entry tRPAREN")
                      # result = s(:masgn, s(:array, val_[1]))
                      ofs = val[vofs ].src_offset  #  of the tLPAREN
                      result = new_parasgn( RubyArrayNode.s(val[vofs + 1]) , ofs )
                    }

      mlhs_basic: mlhs_head
                    {
		      yTrace("mlhs_basic: mlhs_head ")
                      # result = s(:masgn, val_[0])
                      v_zero = val[vofs ]
                      result = new_parasgn( v_zero , v_zero.src_offset )
                    }
                | mlhs_head mlhs_item
                    {
		      yTrace("mlhs_basic: | mlhs_head mlhs_item")
                      # result = s(:masgn, val_[0] << val_[1].compact)
                      v_zero = val[vofs ]  # a RubyArrayNode
                      v_one = val[vofs + 1]
                      unless v_zero.append_for_mlhs( v_one )
                        yyerror("unexpected additional args after &<anArg> in block param list")
                      end
                      ofs = v_one.src_offset 
                      result = new_parasgn( v_zero, ofs )
                    }
                | mlhs_head tAMPER variable
                    { 
                      yTrace("mlhs_basic: | mlhs_head tAMPER variable")
                      unless @env.in_block_params
                        yyerror("unexpected & in parallel assignment, not on last param to a block")
                      end
                      v_zero = val[vofs ]
                      v_two = val[vofs + 2]
                      ofs = v_two.src_offset
                      lv = self.assignable(v_two, nil)
                      lv.setAmpersandBlockParam
                      unless v_zero.append_for_mlhs( lv )
                        yyerror("unexpected additional args after &<anArg> in block param list")
                      end
                      result = new_parasgn( v_zero, ofs )
                    }
                | mlhs_head tSTAR mlhs_node
                    { 
		      yTrace("mlhs_basic: | mlhs_head tSTAR mlhs_node")
                      # result = s(:masgn, val_[0] << s(:splat, val_[2])) 
                      v_zero = val[vofs ]  # a RubyArrayNode
                      ofs = val[vofs + 1].src_offset # of the tSTAR
                      unless v_zero.append_for_mlhs(  RubySplatNode.s(val[vofs + 2] ))
                        yyerror("unexpected additional args after &<anArg> in block param list")
                      end
                      result = new_parasgn( v_zero , ofs )
                    }
                | mlhs_head tSTAR
                    {
		      yTrace("mlhs_basic: | mlhs_head tSTAR")
                      # result = s(:masgn, val_[0] << s(:splat))
                      v_zero = val[vofs ]  
                      unless v_zero.append_for_mlhs(  RubySplatNode.s( nil ))
                        yyerror("unexpected additional args after &<anArg> in block param list")
                      end
                      ofs = val[vofs + 1].src_offset  #  of the tSTAR
                      result = new_parasgn( v_zero, ofs )
                    }
                | tSTAR mlhs_node
                    {  
		      yTrace("mlhs_basic: | tSTAR mlhs_node")
                      # result = s(:masgn, s(:array, s(:splat, val_[1])))
                      ofs = val[vofs ].src_offset  #  of the tSTAR
             result = new_parasgn( RubyArrayNode.s( RubySplatNode.s( val[vofs + 1])), ofs )
                    }
                | tAMPER variable
                    {
                      yTrace("mlhs_basic: | tAMPER variable")
                      unless @env.in_block_params
                        yyerror("unexpected & in parallel assignment, not on last param to a block")
                      end
                      v_one = val[vofs + 1]
                      lv = self.assignable(v_one, nil)
                      lv.setAmpersandBlockParam
                      result = new_parasgn( RubyArrayNode.s( lv), nil)
                    }           
                | tSTAR
                    {
		      yTrace("mlhs_basic: | tSTAR")
                      # result = s(:masgn, s(:array, s(:splat)))
                      ofs = val[vofs ].src_offset  #  of the tSTAR
                result = new_parasgn( RubyArrayNode.s( RubySplatNode.s(nil)), ofs )
                    }

       mlhs_item: mlhs_node          Y_TRACE_val_vofs("mlhs_item: mlhs_node")
                | tLPAREN mlhs_entry tRPAREN
                    {
		      yTrace("mlhs_item: tLPAREN mlhs_entry tRPAREN")
                      result = val[vofs + 1] 
                    }

       mlhs_head: mlhs_item tCOMMA
                    {
		      yTrace("mlhs_head: mlhs_item tCOMMA")
                      # result = s(:array, val_[0]) # mlhs_head: mlhs_item tCOMMA
                      result = RubyArrayNode.s( val[vofs ])
                    }
                | mlhs_head mlhs_item tCOMMA
                    {
		      yTrace("mlhs_head: | mlhs_head mlhs_item tCOMMA")
                      # result = val_[0] << val_[1].compact
                      v_zero = val[vofs ]
                      unless v_zero.append_for_mlhs( val[vofs + 1] )
                        yyerror("unexpected additional args after &<anArg> in block param list")
                      end
                      result = v_zero
                    }

       mlhs_node: variable
                    {
		      yTrace("mlhs_node: variable")
                      result = self.assignable(val[vofs ], nil)
                    }
                | primary_value tLBRACK_STR aref__args tRBRACK
                    {
		      yTrace("mlhs_node: | primary_value tLBRACK_STR aref__args tRBRACK")
                      result = RubyAttrAssignNode.s(val[vofs ], :"[]=", val[vofs + 2] )
                      result.src_offset=( val[vofs + 3].src_offset )  # position of tRBRACK
                    }
                | primary_value tDOT tIDENTIFIER
                    {
		      yTrace("mlhs_node: | primary_value tDOT tIDENTIFIER")
                      # result = s(:attrasgn, val_[0], :"#{val_[2]}=", s(:arglist))
                      # the  tIDENTIFIER value will be a RpNameToken
                      #  all places where we send   symval   we expect a  RpNameToken
                     result = RubyAttrAssignNode.s_tk(val[vofs ], val[vofs + 2], nil )
                    }
                | primary_value tCOLON2 tIDENTIFIER
                    {
		      yTrace("mlhs_node: | primary_value tCOLON2 tIDENTIFIER")
                      # result = s(:attrasgn, val_[0], :"#{val_[2]}=", s(:arglist))
                      # the  tIDENTIFIER value will be a RpNameToken
                      result = RubyAttrAssignNode.s_tk( val[vofs ], val[vofs + 2], nil )
                    }
                | primary_value tDOT tCONSTANT
                    {
		      yTrace("mlhs_node: | primary_value tDOT tCONSTANT")
                      # result = s(:attrasgn, val_[0], :"#{val_[2]}=", s(:arglist))
                      result = RubyAttrAssignNode.s_tk( val[vofs ], val[vofs + 2], nil)
                    }
                | primary_value tCOLON2 tCONSTANT
                    {
		      yTrace("mlhs_node: | primary_value tCOLON2 tCONSTANT")
                      if (@in_def || @in_single > 0) then
                        raise SyntaxError,  "dynamic constant assignment"
                      end
                    # all RubyColon2Node.s  expect second arg to be a RpNameToken
                    #  result = s(:const, s(:colon2, val_[0], val_[2].to_sym), nil)
             nam = val[vofs + 2]
             result = RubyConstDeclNode.s( RubyColon2Node.s( val[vofs ], nam ), nil)
             result.src_offset=( nam.src_offset )
                    }
                | tCOLON3 tCONSTANT
                    {
		      yTrace("mlhs_node: | tCOLON3 tCONSTANT")
                      if (@in_def || @in_single > 0) then
                        raise SyntaxError,  "dynamic constant assignment"
                      end
                      # all RubyColon3Node.s  expects arg to be a RpNameToken
                      # result = s(:const, nil, s(:colon3, val_[1].to_sym))
                   nam = val[vofs + 1]
                   result = RubyConstDeclNode.s( RubyColon3Node.s( nam ), nil )
                   result.src_offset=( nam.src_offset )
                    }
                | backref
                    {
		      yTrace("mlhs_node: | backref")
                      self.backref_assign_error( val[vofs ] ) 
                      result = val[vofs]
                    }

             lhs: variable
                    {
		      yTrace("lhs: variable")
                      result = self.assignable(val[vofs ], nil)
                    }
                | primary_value tLBRACK_STR aref__args tRBRACK
                    {
		      yTrace("lhs: | primary_value tLBRACK_STR aref__args tRBRACK")
                      result = RubyAttrAssignNode.s(val[vofs ], :"[]=", val[vofs + 2] )
                      result.src_offset=( val[vofs + 3].src_offset )  # position of tRBRACK
                    }
                | primary_value tDOT tIDENTIFIER
                    {
		      yTrace("lhs: | primary_value tDOT tIDENTIFIER")
                      # result = s(:attrasgn, val_[0], :"#{val_[2]}=")
                      # the  tIDENTIFIER value will be a RpNameToken
                      result = RubyAttrAssignNode.s_tk(val[vofs ], val[vofs + 2], nil)
                    }
                | primary_value tCOLON2 tIDENTIFIER
                    {
		      yTrace("lhs: | primary_value tCOLON2 tIDENTIFIER")
                      # result = s(:attrasgn, val_[0], :"#{val_[2]}=")
                      # the  tIDENTIFIER value will be a RpNameToken
		      result = RubyAttrAssignNode.s_tk(val[vofs ], val[vofs + 2], nil)
                    }
                | primary_value tDOT tCONSTANT
                    {
		      yTrace("lhs: | primary_value tDOT tCONSTANT")
                      # result = s(:attrasgn, val_[0], :"#{val_[2]}=")
                      result = RubyAttrAssignNode.s_tk( val[vofs ], val[vofs + 2], nil)
                    }
                | primary_value tCOLON2 tCONSTANT
                    {
		      yTrace("lhs: | primary_value tCOLON2 tCONSTANT")
                      if (@in_def || @in_single > 0) then
                        raise SyntaxError,  "dynamic constant assignment"
                      end
                      # result = s(:const, s(:colon2, val_[0], val_[2].to_sym))
                      nam = val[vofs + 2] 
                      result = RubyConstDeclNode.s( RubyColon2Node.s( val[vofs ], nam ), nil)
                      result.src_offset=( nam.src_offset )
                    }
                | tCOLON3 tCONSTANT
                    {
		      yTrace("lhs: | tCOLON3 tCONSTANT")
                      if (@in_def || @in_single > 0) then
                        raise SyntaxError,  "dynamic constant assignment"
                      end

                      # result = s(:const, s(:colon3, val_[1].to_sym))
                      nam = val[vofs + 1]
                      result = RubyConstDeclNode.s( RubyColon3Node.s( nam ), nil )
                      result.src_offset=( nam.src_offset )
                    }
                | backref
                    {
		      yTrace("lhs: | backref")
                      self.backref_assign_error( val[vofs ] ) 
                      result = val[vofs]
                    }

           cname: tIDENTIFIER
                    {
		      yTrace("cname: tIDENTIFIER")
                      yyerror( "class/module name must be CONSTANT")
                      result = val[vofs]
                    }
                | tCONSTANT Y_TRACE_val_vofs("cname: | tCONSTANT")

           cpath: tCOLON3 cname
                    {
		      yTrace("cpath: tCOLON3 cname")
                      # result = s(:colon3, val_[1].to_sym)
                      result = RubyColon3Node.s( val[vofs + 1] )
                    }
                | cname		
                    {
		      yTrace("cpath: | cname")
                      result = val[vofs]  # a RpNameToken
                    }
                | primary_value tCOLON2 cname
                    {
		      yTrace("cpath: | primary_value tCOLON2 cname")
                      # result = s(:colon2, val_[0], val_[2].to_sym)
                      result =  RubyColon2Node.s( val[vofs ], val[vofs + 2] )
                    }

           fname: tIDENTIFIER | tCONSTANT | tFID
                | op
                    {
		      yTrace("fname: tIDENTIFIER | tCONSTANT | tFID | op")
                      @lexer.lex_state=( Expr_end )
                      result = val[vofs ]   # val_[0] is a RpNameToken
                    }

                | reswords
                    {
		      yTrace("fname: | reswords")
                      @lexer.lex_state=( Expr_end )
                      result = val[vofs ]  # val_[0] is a RpNameToken or a String
                    }

                    # TODO: cruby has fsym and dsym
           fitem: fname  
	            { 
		      yTrace("fitem: fname")
                      v_zero = val[vofs ]  # a RpNameToken
		      result = RubySymbolNode.s( v_zero.symval)  # s(:lit)
                      result.src_offset=( v_zero.src_offset )
                      # fitem - fname path
                    }
                | symbol 
		    { 
		       yTrace("fitem: | symbol")
		       result = RubySymbolNode.s( val[vofs ])  # s(:lit)
			# fitem - symbol path 
                    }

      undef_list: fitem
                    {
		      yTrace("undef_list: fitem")
                      vsym = val[vofs ]   # a RubySymbolNode
                      result = new_undef( vsym )
                      result.src_offset=( val[ vofs - 1 ].src_offset ) # of the kUNDEF
                    }
                | undef_list tCOMMA
                    {
		      yTrace("undef_list: | undef_list tCOMMA")
                      @lexer.lex_state=( Expr_fname )
                    }
                    fitem
                    {
		      yTrace("undef_list: ___ fitem")
                      result = append_undef( val[vofs ], val[vofs + 3] )
                    }

              op: tPIPE    | tCARET     | tAMPER2 | tCMP   | tEQ     | tEQQ
                | tMATCH   | tGT        | tGEQ    | tLT    | tLEQ    | tLSHFT
                | tRSHFT   | tPLUS      | tMINUS  | tSTAR2 | tSTAR   | tDIVIDE
                | tPERCENT | tPOW       | tTILDE  | tUPLUS | tUMINUS | tAREF
                | tASET    | tBACK_REF2

        reswords: k__LINE__ | k__FILE__   | klBEGIN | klEND  | kALIAS  | kAND
                | kBEGIN    | kBREAK      | kCASE   | kCLASS | kDEF    | kDEFINED
                | kDO       | kELSE       | kELSIF  | kEND   | kENSURE | kFALSE
                | kFOR      | kIN         | kMODULE | kNEXT  | kNIL    | kNOT
                | kOR       | kREDO       | kRESCUE | kRETRY | kRETURN | kSELF
                | kSUPER    | kTHEN       | kTRUE   | kUNDEF | kWHEN   | kYIELD
                | kIF_MOD   | kUNLESS_MOD | kWHILE_MOD | kUNTIL_MOD | kRESCUE_MOD

             arg: lhs tEQL arg
                    {
		      yTrace("arg: lhs tEQL arg")
                      result = self.node_assign(val[vofs ], val[vofs + 2])
                    }
                | lhs tEQL arg kRESCUE_MOD arg
                    {
		      yTrace("arg: | lhs tEQL arg kRESCUE_MOD arg")
         # result = self.node_assign(val_[0], s(:rescue, val_[2], s(:resbody, s(:array), val_[4])) )
                      resbody = RubyRescueBodyNode.s(nil, val[vofs + 4])
                      resbody.src_offset=( val[vofs + 3].src_offset )   # kRESCUE_MOD position
                      rescue_nod = RubyRescueNode.s( val[vofs + 2], resbody, nil)
                      rescue_nod.src_offset=( val[vofs + 1].src_offset )   # tEQL position
                      result = self.node_assign(val[vofs ], rescue_nod )        # Fix trac 545
                    }
                | varLhs tOP_ASGN arg
                    {
		      yTrace("arg: | varLhs tOP_ASGN arg")
                      result = new_op_asgn( val, vofs )
                    }
                | primary_value tLBRACK_STR aref__args tRBRACK tOP_ASGN arg
                    {
		      yTrace("arg: | primary_value tLBRACK_STR aref__args tRBRACK tOP_ASGN arg")
                      v_two = val[vofs + 2]
                      unless v_two.class._equal?(RubyRpCallArgs)
                        internal_error('aref__args is not a RubyRpCallArgs')
                      end
                      result = RubyOpElementAsgnNode.s(val[vofs ], v_two, val[vofs + 4], val[vofs + 5])
                    }
                | primary_value tDOT tIDENTIFIER tOP_ASGN arg
                    {
		      yTrace("arg: | primary_value tDOT tIDENTIFIER tOP_ASGN arg")
                      # result = s(:op_asgn2, val_[0], :"#{val_[2]}=", val_[3].to_sym, val_[4])
                      # val_[2], val_[3] are RpNameToken
                     result = RubyOpAsgnNode.s(val[vofs ], val[vofs + 2], val[vofs + 3], val[vofs + 4])
                    }
                | primary_value tDOT tCONSTANT tOP_ASGN arg
                    {
		     yTrace("arg: | primary_value tDOT tCONSTANT tOP_ASGN arg")
                     # result = s(:op_asgn2, val_[0], :"#{val_[2]}=", val_[3].to_sym, val_[4])
                     # val_[2], val_[3] are RpNameToken
	             result = RubyOpAsgnNode.s(val[vofs ], val[vofs + 2], val[vofs + 3], val[vofs + 4])
                    }
                | primary_value tCOLON2 tIDENTIFIER tOP_ASGN arg
                    {
		      yTrace("arg: | primary_value tCOLON2 tIDENTIFIER tOP_ASGN arg")
                      internal_error(":op_asgn never seen from MRI parser ")
                      # result = s(:op_asgn, val_[0], val_[4], val_[2], val_[3])
                      result = nil
                    }
                | primary_value tCOLON2 tCONSTANT tOP_ASGN arg

                    {
		      yTrace("arg: | primary_value tCOLON2 tCONSTANT tOP_ASGN ar")
                      yyerror "constant re-assignment"
                    }
                | tCOLON3 tCONSTANT tOP_ASGN arg
                    {
		      yTrace("arg: | tCOLON3 tCONSTANT tOP_ASGN arg")
                      yyerror "constant re-assignment"
                    }
                | backref tOP_ASGN arg
                    {
		      yTrace("arg: | backref tOP_ASGN arg")
                      self.backref_assign_error( val[vofs ])  
                      result = val[vofs]
                    }
                | arg tDOT2 arg
                    {
		      yTrace("arg: | arg tDOT2 arg")
                      v1 = val[vofs ]
                      v2 = val[vofs + 2]
                      result = RubyDotNode.s(:dot2, v1, v2)
		      result.src_offset=( val[vofs + 1 ].src_offset ) # of the DOT2
                    }
                | arg tDOT3 arg
                    {
		      yTrace("arg: | arg tDOT3 arg")
                      v1 = val[vofs ]
                      v2 = val[vofs + 2]
                      result = RubyDotNode.s(:dot3, v1, v2)
		      result.src_offset=( val[vofs + 1 ].src_offset ) # of the DOT3
                    }
                | arg tPLUS arg
                    {
		      yTrace("arg: | arg tPLUS arg")
                      result = new_call_1(val[vofs ], val[vofs + 1],  val[vofs + 2]  ) 
                    }
                | arg tMINUS arg
                    {
		      yTrace("arg: | arg tMINUS arg")
                      result = new_call_1(val[vofs ], val[vofs + 1],  val[vofs + 2]  )
                    }
                | arg tSTAR2 arg
                    {
		      yTrace("arg: | arg tSTAR2 arg")
                      result = new_call_1(val[vofs ], val[vofs + 1], val[vofs + 2]  )
                    }
                | arg tDIVIDE arg
                    {
		      yTrace("arg: | arg tDIVIDE arg")
                      result = new_call_1( val[vofs ], val[vofs + 1], val[vofs + 2] )  # tDIVIDE_a
                    }
                | arg tPERCENT arg
                    {
		      yTrace("arg: | arg tPERCENT arg")
                      result = new_call_1(val[vofs ], val[vofs + 1] , val[vofs + 2] )  # tPERCENT_a
                    }
                | arg tPOW arg
                    {
		      yTrace("arg: | arg tPOW arg")
                      result = new_call_1(val[vofs ], val[vofs + 1], val[vofs + 2] ) # tPOW_a
                    }
                | tUMINUS_NUM tINTEGER tPOW arg
                    {
		      yTrace("arg: | tUMINUS_NUM tINTEGER tPOW arg")
                      lit_one =  RubyAbstractNumberNode.s( val[vofs + 1])  # s(:lit )
                      pow_sel = val[vofs + 2]
                      minus_sel = RpNameToken.new( :"-@" , pow_sel.src_offset )
                      result = new_vcall( new_call_1( lit_one, pow_sel, val[vofs + 3] ), minus_sel )
                    }
                | tUMINUS_NUM tFLOAT tPOW arg
                    {
		      yTrace("arg: | tUMINUS_NUM tFLOAT tPOW arg")
                      lit_one = RubyAbstractNumberNode.s( val[vofs + 1])  # s(:lit )
                      pow_sel = val[vofs + 2]
                      minus_sel = RpNameToken.new( :"-@" , pow_sel.src_offset )
                      result = new_vcall(new_call_1( lit_one, pow_sel, val[vofs + 3] ), minus_sel )
                    }
                | tUPLUS arg
                    {
		      yTrace("arg: | tUPLUS arg")
                      v_one = val[vofs + 1]
                      if v_one._kind_of?(RubyAbstractLiteralNode) # val_[1][0] == :lit 
                        result = v_one
                      else
                        sel_tok = RpNameToken.new( :"+@" , val[vofs ].src_offset )
                        result = new_vcall( v_one, sel_tok )
                      end
                    }
                | tUMINUS arg
                    {
		      yTrace("arg: | tUMINUS arg")
                      sel_tok = RpNameToken.new( :"-@" , val[vofs ].src_offset )
                      result = new_vcall( val[vofs + 1], sel_tok )
                    }
                | arg tPIPE arg
                    {
		      yTrace("arg: | arg tPIPE arg")
                      result = new_call_1( val[vofs ], val[vofs + 1],  val[vofs + 2] )
                    }
                | arg tCARET arg
                    {
		      yTrace("arg: | arg tCARET arg")
                      result = new_call_1(val[vofs ], val[vofs + 1],  val[vofs + 2] )
                    }
                | arg tAMPER2 arg
                    {
		      yTrace("arg: | arg tAMPER2 arg")
                      result = new_call_1(val[vofs ], val[vofs + 1],  val[vofs + 2] )
                    }
                | arg tCMP arg
                    {
		      yTrace("arg: | arg tCMP arg")
                      result = new_call_1(val[vofs ], val[vofs + 1], val[vofs + 2] )
                    }
                | arg tGT arg
                    {
		      yTrace("arg: | arg tGT arg")
                      result = new_call_1(val[vofs ], val[vofs + 1], val[vofs + 2] )
                    }
                | arg tGEQ arg
                    {
		      yTrace("arg: | arg tGEQ arg")
                      result = new_call_1(val[vofs ], val[vofs + 1], val[vofs + 2] )
                    }
                | arg tLT arg
                    {
		      yTrace("arg: | arg tLT arg")
                      result = new_call_1(val[vofs ], val[vofs + 1],  val[vofs + 2] )
                    }
                | arg tLEQ arg
                    {
		      yTrace("arg: | arg tLEQ arg")
                      result = new_call_1(val[vofs ], val[vofs + 1],  val[vofs + 2] )
                    }
                | arg tEQ arg
                    {
		      yTrace("arg: | arg tEQ arg")
                      result = new_call_1(val[vofs ], val[vofs + 1], val[vofs + 2] )
                    }
                | arg tEQQ arg
                    {
		      yTrace("arg: | arg tEQQ arg")
                      result = new_call_1(val[vofs ], val[vofs + 1],  val[vofs + 2] )
                    }
                | arg tNEQ arg
                    {
		      yTrace("arg: | arg tNEQ arg")
					# TODOryan: port call_op and clean these
                      v_zero = value_expr(val[vofs ] ) 
                      v_two = value_expr( val[vofs + 2])
                      sel_tok = RpNameToken.new( :"==" , val[vofs + 1].src_offset ) 
                      result = RubyNotNode.s( new_call_1(v_zero, sel_tok,  v_two ) ) # s(:not )
                    }
                | arg tMATCH arg
                    {
		      yTrace("arg: | arg tMATCH arg")
                      result = self.get_match_node( val[vofs ], val[vofs + 1], val[vofs + 2] )
                    }
                | arg tNMATCH arg
                    {
		      yTrace("arg: | arg tNMATCH arg")
                      result = RubyNotNode.s( self.get_match_node(val[vofs ], val[vofs + 1], val[vofs + 2])) # s(:not )
                    }
                | tBANG arg
                    {
		      yTrace("arg: | tBANG arg")
                      result = RubyNotNode.s( val[vofs + 1]) # s(:not )
                    }
                | tTILDE arg
                    {
		      yTrace("arg: | tTILDE arg")
                      # val_[0] already a NameToken
                      # val_[2] = value_expr( val[2]) # TODO ask ryan , why ??
                      # result = new_call val_[1], :"~", s(:arglist)
                      v_one = value_expr( val[vofs + 1] )
                      result = new_vcall( v_one, val[vofs ] )
                    }
                | arg tLSHFT arg
                    {
		      yTrace("arg: | arg tLSHFT arg")
                      v_zero = value_expr( val[vofs ])
	              v_two = value_expr( val[vofs + 2])
                      result = new_call_1(v_zero, val[vofs + 1],  v_two  )
                    }
                | arg tRSHFT arg
                    {
		      yTrace("arg: | arg tRSHFT arg")
                      v_zero = value_expr( val[vofs ])
                      v_two = value_expr( val[vofs + 2])
                      result = new_call_1(v_zero , val[vofs + 1],  v_two )
                    }
                | arg tANDOP arg
                    {
		      yTrace("arg: | arg tANDOP arg")
                      result = logop( RubyAndNode, val[vofs ], val[vofs + 2]) # s(:and )
                    }
                | arg tOROP arg
                    {
		      yTrace("arg: | arg tOROP arg")
                      result = logop( RubyOrNode, val[vofs ], val[vofs + 2]) # s(:or )
                    }
                | kDEFINED opt_nl arg
                    {
		      yTrace("arg: | kDEFINED opt_nl arg")
                      result = RubyDefinedNode.s( val[vofs + 2])  # s(:defined )
                    }
                | arg tEH arg tCOLON arg
                    {
		      yTrace("arg: | arg tEH arg tCOLON arg")
                      result = RubyIfNode.s(val[vofs ], val[vofs + 2], val[vofs + 4]) # s(:if )
                    }
                | primary Y_TRACE_val_vofs("arg: | primary")

       arg_value: arg
                    { 
		      yTrace("arg_value: arg")
                      result = value_expr(val[vofs ])
                    }

       aref__args: none            Y_TRACE_val_vofs("aref__args: none")
                | command opt_nl
                    {
		      yTrace("aref__args: | command opt_nl")
                      warning('parenthesize argument(s) for future version')
                      # result = s(:array, val_[0])
                      result = RubyRpCallArgs.s( val[vofs ])
                    }
                | args trailer
                    {
                      yTrace("aref__args: | args trailer");
                      result = val[vofs ]
                    }
                | args tCOMMA tSTAR arg opt_nl
                    {
		      yTrace("aref__args: | args tCOMMA tSTAR arg opt_nl")
                      result = val[vofs ]
                      result.append( RubySplatNode.s( val[vofs + 3] ))
                    }
                | assocs trailer
                    {
		      yTrace("aref__args: | assocs trailer")
                      # result = s(:array, s(:hash, *val_[0].values))
                      result = RubyRpCallArgs.s( RubyHashNode.s( val[vofs ] ))
                    }
                | tSTAR arg opt_nl
                    {
		      yTrace("aref__args: | tSTAR arg opt_nl")
                      # result = s(:array, s(:splat, val_[1]))
                     result = RubyRpCallArgs.s( RubySplatNode.s( val[vofs + 1])) 
                    }

      paren_args: tLPAREN2 none tRPAREN
                    {
		      yTrace("paren_args: tLPAREN2 none tRPAREN")
                      result = val[vofs + 1]
                    }
                | tLPAREN2 call_args opt_nl tRPAREN
                    {
		      yTrace("paren_args: | tLPAREN2 call_args opt_nl tRPAREN")
                      result = val[vofs + 1]
                    }
                | tLPAREN2 block_call opt_nl tRPAREN
                    {
		      yTrace("paren_args: | tLPAREN2 block_call opt_nl tRPAREN")
                      warning( "parenthesize argument(s) for future version")
                      # result = s(:array, val_[1])
                      result = RubyRpCallArgs.s( val[vofs + 1])
                    }
                | tLPAREN2 args tCOMMA block_call opt_nl tRPAREN
                    {
		      yTrace("paren_args: | tLPAREN2 args tCOMMA block_call opt_nl tRPAREN")
                      warning( "parenthesize argument(s) for future version")
                      # result = val_[1].add val_[3]
                      result = val[vofs + 1].append(  val[vofs + 3] )
                    }

  opt_paren_args: none       Y_TRACE_val_vofs("opt_paren_args: none")
                | paren_args Y_TRACE_val_vofs("opt_paren_args: paren_args")

       call_args: command
                    {
		      yTrace("call_args: command")
                      warning( "parenthesize argument(s) for future version")
                      # result = s(:array, val_[0])
                      result = RubyRpCallArgs.s( val[vofs ])
                    }
                | args opt_block_arg
                    {
		      yTrace("call_args: | args opt_block_arg")
                      result = val[vofs ]  # should be a RubyRpCallArgs
                      result.append_blk_arg( val[vofs + 1])
                    }
                | args tCOMMA tSTAR arg_value opt_block_arg
                    {
		      yTrace("call_args: | args tCOMMA tSTAR arg_value opt_block_arg")
                      result = val[vofs ]  # should be a RubyRpCallArgs
                      result.append_arg( RubySplatNode.s( val[vofs + 3]) )
                      result.append_blk_arg( val[vofs + 4])
                    }
                | assocs opt_block_arg
                    {
		      yTrace("call_args: | assocs opt_block_arg")
                      # result = s(:array, s(:hash, *val_[0].values))
                      result = RubyRpCallArgs.s( RubyHashNode.s( val[vofs ] ))
                      result.append_blk_arg( val[vofs + 1] )
                    }
                | assocs tCOMMA tSTAR arg_value opt_block_arg
                    {
		      yTrace("call_args: | assocs tCOMMA tSTAR arg_value opt_block_arg")
                      # result = self.arg_concat s(:array, s(:hash, *val_[0].values)), val_[3]
                      result = RubyRpCallArgs.s( RubyHashNode.s( val[vofs ]) )
                      result.append_arg( RubySplatNode.s( val[vofs + 3] ) )
                      result.append_blk_arg( val[vofs + 4] )
                    }
                | args tCOMMA assocs opt_block_arg
                    {
		      yTrace("call_args: | args tCOMMA assocs opt_block_arg")
                      # result = val_[0] << s(:hash, *val_[2].values)
                      result = val[vofs ]
                      result.append_arg( RubyHashNode.s( val[vofs + 2] ))
                      result.append_blk_arg( val[vofs + 3])
                    }
                | args tCOMMA assocs tCOMMA tSTAR arg opt_block_arg
                    {
		      yTrace("call_args: | args tCOMMA assocs tCOMMA tSTAR arg opt_block_arg")
                      # val_[0] << s(:hash, *val_[2].values)
                      result = val[vofs ]
                      result.append_arg( RubyHashNode.s( val[vofs + 2] ))
                      result.append_arg( RubySplatNode.s( val[vofs + 5] ))
                      result.append_blk_arg( val[vofs + 6])
                    }
                | tSTAR arg_value opt_block_arg
                    {
		      yTrace("call_args: | tSTAR arg_value opt_block_arg")
                      # result = self.arg_blk_pass s(:splat, val_[1]), val_[2]
                      result = RubyRpCallArgs.s( RubySplatNode.s( val[vofs + 1]))
                      result.append_blk_arg( val[vofs + 2] )
                    }
                | block_arg Y_TRACE_val_vofs("call_args: | block_arg")

      call_args2: arg_value tCOMMA args opt_block_arg
                    {
		      yTrace("call_args2: arg_value tCOMMA args opt_block_arg")
                      args = self.list_prepend( val[vofs + 2], val[vofs ] )
                      result = args.append_blk_arg( val[vofs + 3] )
                    }
                | arg_value tCOMMA block_arg
                    {
		      yTrace("call_args2: | arg_value tCOMMA block_arg")
                      result = RubyRpCallArgs.s( val[vofs ])
                      result.append_blk_arg( val[vofs + 2])
                    }
                | arg_value tCOMMA tSTAR arg_value opt_block_arg
                    {
		      yTrace("call_args2: | arg_value tCOMMA tSTAR arg_value opt_block_arg")
                      result = RubyRpCallArgs.s( val[vofs ])
                      result.append_arg( RubySplatNode.s( val[vofs + 3] ))
                      result.append_blk_arg( val[vofs + 4] )
                    }
                | arg_value tCOMMA args tCOMMA tSTAR arg_value opt_block_arg
                    {
		      yTrace("call_args2: | arg_value tCOMMA args tCOMMA tSTAR arg_value opt_block_arg")
                      #result = self.arg_concat s(:array, val_[0], s(:hash, *val_[2].values)), val_[5]
                      result = RubyRpCallArgs.s(val[vofs ], RubyHashNode.s( val[vofs + 2]) )
                      result.append_arg( val[vofs + 5])
                      result.append_blk_arg( val[vofs + 6] )
                    }
                | assocs opt_block_arg
                    {
		      yTrace("call_args2: | assocs opt_block_arg")
                      # result = s(:array, s(:hash, *val_[0].values))
                      result = RubyRpCallArgs.s( RubyHashNode.s( val[vofs ] ))
                      result.append_blk_arg( val[vofs + 1])
                    }
                | assocs tCOMMA tSTAR arg_value opt_block_arg
                    {
		      yTrace("call_args2: | assocs tCOMMA tSTAR arg_value opt_block_arg")
                      result = RubyRpCallArgs.s( RubyHashNode.s( val[vofs ]), RubySplatNode.s(val[vofs + 3]) )
                      result.append_blk_arg( val[vofs + 4] )
                    }
                | arg_value tCOMMA assocs opt_block_arg
                    {
		      yTrace("call_args2: | arg_value tCOMMA assocs opt_block_arg")
                      # result = s(:array, val_[0], s(:hash, *val_[2].values))
                      result = RubyRpCallArgs.s( val[vofs ], RubyHashNode.s( val[vofs + 2]))
                      result.append_blk_arg( val[vofs + 3] )
                    }
                | arg_value tCOMMA args tCOMMA assocs opt_block_arg
                    {
		      yTrace("call_args2: | arg_value tCOMMA args tCOMMA assocs opt_block_arg")
                      result = RubyRpCallArgs.s( val[vofs ] )
                      result.appendAll( val[vofs + 2] ) 
                      result.append_arg( RubyHashNode.s( val[vofs + 4] ))
                      result.append_blk_arg( val[vofs + 5] )
                    }
                | arg_value tCOMMA assocs tCOMMA tSTAR arg_value opt_block_arg
                    {
		      yTrace("call_args2: | arg_value tCOMMA assocs tCOMMA tSTAR arg_value opt_block_arg")
                      result = RubyRpCallArgs.s( val[vofs ] , RubyHashNode.s( val[vofs + 2] ))
                      result.append_arg( RubySplatNode.s( val[vofs + 5] ))
                      result.append_blk_arg( val[vofs + 6] )
                    }
                | arg_value tCOMMA args tCOMMA assocs tCOMMA tSTAR arg_value opt_block_arg
                    {
		      yTrace("call_args2: | arg_value tCOMMA args tCOMMA assocs tCOMMA tSTAR arg_value opt_block_arg")
                      result = RubyRpCallArgs.s( val[vofs ] )
                      result.appendAll( val[vofs + 2] )  
                      result.append_arg( RubyHashNode.s( val[vofs + 4] ))
                      result.append_arg( RubySplatNode.s( val[vofs + 7]))
                      result.append_blk_arg( val[vofs + 8])
                    }
                | tSTAR arg_value opt_block_arg
                    {
		      yTrace("call_args2: | tSTAR arg_value opt_block_arg")
                      result = RubyRpCallArgs.s( RubySplatNode.s( val[vofs + 1]))
                      result.result.append_blk_arg( val[vofs + 2] )
                    }
                | block_arg Y_TRACE_val_vofs("call_args2: | block_arg")

    command_args:   {
		      yTrace("command_args:")
		      lex_cmdarg = @lexer.cmdarg_ 
                      result = lex_cmdarg.dup
                      lex_cmdarg.push( true )
                    }
                    open_args
                    {
		      yTrace("command_args: ___  open_args")
                      # @lexer.cmdarg_.stack.replace( val_[0] )
                      @lexer.cmdarg=( val[vofs ].dup  )
                      result = val[vofs + 1]
                    }

       open_args: call_args     Y_TRACE_val_vofs("open_args: call_args")
                | tLPAREN_ARG
                    {
		      yTrace("open_args: tLPAREN_ARG")
                      @lexer.lex_state=( Expr_endArg )
                      result = val[vofs]
                    }
                    tRPAREN
                    {
		      yTrace("open_args: ___ tRPAREN")
        msg = "don't put space before argument parentheses, near line #{@lexer.lineno_}"
                      if @mydebug ; msg << " (B)" ; end 
                      warning(msg)
                      result = nil
                    }
                | tLPAREN_ARG call_args2
                    {
		      yTrace("open_args: | tLPAREN_ARG call_args2")
                      @lexer.lex_state=( Expr_endArg )
                      result = val[vofs]
                    }
                    tRPAREN
                    {
		      yTrace("open_args: ___ tRPAREN")
		      #    tRPAREN
        msg = "don't put space before argument parentheses, near line #{@lexer.lineno_}"
                      if @mydebug ; msg << " (C)" ; end 
                      warning(msg)
                      result = val[vofs + 1]
                    }

       block_arg: tAMPER arg_value
                    {
		      yTrace("block_arg: tAMPER arg_value")
                      # result = s(:block_pass, val_[1])
                      result = RubyBlockPassNode.s(val[vofs + 1])
                    }

   opt_block_arg: tCOMMA block_arg
                    {
		      yTrace("opt_block_arg: tCOMMA block_arg")
                      result = val[vofs + 1]
                    }
                | none_block_pass    Y_TRACE_val_vofs("opt_block_arg: none_block_pass")

            args: arg_value
                    {
		      yTrace("args: arg_value")
                      result = RubyRpCallArgs.s( val[vofs ]) # s(:array )
                    }
                | args tCOMMA arg_value
                    {
		      yTrace(" args: | args tCOMMA arg_value")
                      result = val[vofs ]
                      result.append_arg( val[vofs + 2])
                    }

            mrhs: args tCOMMA arg_value
                    {
		      yTrace("mrhs: args tCOMMA arg_value")
                      result = val[vofs ]
                      result.append_arg( val[vofs + 2] )
                    }
                | args tCOMMA tSTAR arg_value
                    {
		      yTrace("mrhs: | args tCOMMA tSTAR arg_value")
                      result = val[vofs ]
                      result.append_arg( RubySplatNode.s( val[vofs + 3]))
                    }
                | tSTAR arg_value
                    {
		      yTrace("mrhs: | tSTAR arg_value")
                      result = RubySplatNode.s( val[vofs + 1])  # s(:splat ) 
                    }

         primary: literal   Y_TRACE_val_vofs("primary: literal")
                | strings   Y_TRACE_val_vofs("primary: strings")
                | xstring   Y_TRACE_val_vofs("primary: xstring")
                | regexp    Y_TRACE_val_vofs("primary: regexp")
                | words     Y_TRACE_val_vofs("primary: words")
                | awords    Y_TRACE_val_vofs("primary: awords")
                | var_ref   Y_TRACE_val_vofs("primary: var_ref")
                | backref   Y_TRACE_val_vofs("primary: backref")
                | tFID
                    {
		      yTrace("primary: tFID")
                      result = new_fcall( val[vofs ], nil) 
                    }
                | kBEGIN body_stamt kEND
                    {
		      yTrace("primary: | kBEGIN body_stamt kEND")
                      if val[vofs + 2]._equal?( :tEOF )
                        raise SyntaxError, 'unexpected $end, expecting kEND for kBEGIN'
                      end
                      v_two = val[vofs + 1]  # the  body_stamt
                      unless v_two then
                        result = RubyNilNode._new # s(:nil)
                      else
                        result = RubyBeginNode.s( v_two ) # s(:begin )
                      end
                    }
                | tLPAREN_ARG expr
                    {
		      yTrace("primary: | tLPAREN_ARG expr")
                      @lexer.lex_state=( Expr_endArg )
                      result = val[vofs]
                    }
                    opt_nl tRPAREN
                    {
		      yTrace("primary: ___ opt_nl tRPAREN")
          warning "(...) interpreted as grouped expression, near line #{@lexer.lineno_}"
                      result = val[vofs + 1]
                    }
                | tLPAREN comp_stamt tRPAREN
                    {
		      yTrace("primary: | tLPAREN comp_stamt tRPAREN")
                      # result = val_[1] || s(:nil)
                      result = val[vofs + 1] || RubyNilNode._new 
                      result.paren=( true )
                    }
                | primary_value tCOLON2 tCONSTANT
                    {
		      yTrace("primary: | primary_value tCOLON2 tCONSTANT")
                      # result = s(:colon2, val_[0], val_[2].to_sym) 
                      result = RubyColon2Node.s( val[vofs ], val[vofs + 2])
                    }
                | tCOLON3 tCONSTANT
                    {
		      yTrace("primary: | tCOLON3 tCONSTANT")
                      # result = s(:colon3, val_[1].to_sym)  
                      result = RubyColon3Node.s( val[vofs + 1])
                    }
                | primary_value tLBRACK_STR aref__args tRBRACK
                    {
		      yTrace("primary: | primary_value tLBRACK_STR aref__args tRBRACK")
                      result = new_aref( val, vofs )
                    }
                | tLBRACK aref__args tRBRACK
                    {
		      yTrace("primary: | tLBRACK aref__args tRBRACK")
                      # result = val_[1] || s(:array)
                      result = val[vofs + 1] || RubyRpCallArgs._new 
                    }
                | tLBRACE assoc_list tRCURLY
                    {
		      yTrace("primary: | tLBRACE assoc_list tRCURLY")
                      # result = s(:hash, *val_[1].values)
                      result = RubyHashNode.s( val[vofs + 1] )
                    }
                | kRETURN
                    {
		      yTrace("primary: | kRETURN")
                      # result = s(:return)
                      result = RubyReturnNode.s(nil)
		      result.src_offset=( val[vofs ].src_offset ) # of the kRETURN
                    }
                | kYIELD tLPAREN2 call_args tRPAREN
                    {
		      yTrace("primary: | kYIELD tLPAREN2 call_args tRPAREN")
                      result = new_yield( val[vofs + 2])  
                      result.src_offset=( val[vofs ].src_offset ) # of the kYIELD
                    }
                | kYIELD tLPAREN2 tRPAREN
                    {
		      yTrace("primary: | kYIELD tLPAREN2 tRPAREN")
                      result = new_yield_0
                      result.src_offset=( val[vofs ].src_offset ) # of the kYIELD
                    }
                | kYIELD
                    {
		      yTrace("primary: | kYIELD")
                      result = new_yield_0
                      result.src_offset=( val[vofs ].src_offset ) # of the kYIELD
                    }
                | kDEFINED opt_nl tLPAREN2 expr tRPAREN
                    {
		      yTrace("primary: | kDEFINED opt_nl tLPAREN2 expr tRPAREN")
                      result = RubyDefinedNode.s( val[vofs + 3])   # s(:defined )
                    }
                | operation brace_blck
                    {
		      yTrace("primary: | operation brace_blck")
                      oper = val[vofs ]
                      iter = val[vofs + 1]
                      call = new_fcall( oper, nil  )  # zero args
                      # iter.insert(1, call)
                      iter.call=(call)
                      result = iter
                      # call.line ||= iter.line
                    }
                | method_call    Y_TRACE_val_vofs("primary: method_call")
                | method_call brace_blck
                    {
		      yTrace("primary: | method_call brace_blck")
                      call = val[vofs ]		
                      iter = val[vofs + 1]
                      iter.call=(call)
                      result = iter
                    }
                | kIF expr_value then comp_stamt if_tail kEND
                    {
		      yTrace("primary: | kIF expr_value then comp_stamt if_tail kEND")
                      if val[vofs + 5]._equal?( :tEOF )
                        premature_eof( val[vofs ] )
                      end
                      result = new_if( val[vofs + 1], val[vofs + 3], val[vofs + 4] )
                      result.src_offset=( val[vofs ].src_offset )
                    }
                | kUNLESS expr_value then comp_stamt opt_else kEND
                    {
		      yTrace("primary: | kUNLESS expr_value then comp_stamt opt_else kEND")
                      if val[vofs + 5]._equal?( :tEOF )
                        premature_eof( val[vofs ] )
                      end
                      result = new_if( val[vofs + 1], val[vofs + 4], val[vofs + 3])
                      result.src_offset=( val[vofs ].src_offset )
                    }
                | kWHILE
                    {
		      yTrace("primary: | kWHILE")
                      @lexer.cond_.push( true )
                      result = val[vofs]
                    }
                    expr_value do
                    {
		      yTrace("primary: kWHILE ___ expr_value do")
                      @lexer.cond_.pop
                      result = val[vofs]
                    }
                    comp_stamt kEND
                    {
		      yTrace("primary: kWHILE ___ comp_stamt kEND")
                      if val[vofs + 6]._equal?(:tEOF)
                        premature_eof( val[vofs ] )
                      end
                      result = new_while( val[vofs + 5], val[vofs + 2])
                      result.src_offset=( val[vofs ].src_offset) # kWhile is a RpNameToken
                    }
                | kUNTIL
                    {
		      yTrace("primary: | kUNTIL")
                      @lexer.cond_.push( true )
                      result = val[vofs]
                    }
                    expr_value do
                    {
		      yTrace("kUNTIL ___ expr_value do")
                      @lexer.cond_.pop
                      result = val[vofs]
                    }
                    comp_stamt kEND
                    {
		      yTrace("kUNTIL ___ comp_stamt kEND")
                      if val[vofs + 6]._equal?(:tEOF)
                        premature_eof( val[vofs ] )
                      end
                      result = new_until( val[vofs + 5], val[vofs + 2] )
                      result.src_offset=( val[vofs ].src_offset ) # kUNTIL RpNameToken
                    }
                | kCASE expr_value opt_termms case_body kEND
                    {
		      yTrace("primary: | kCASE expr_value opt_termms case_body kEND")
                      if val[vofs + 4]._equal?( :tEOF )
                        premature_eof( val[vofs ] )
                      end
                      result = new_case( val[vofs + 1], val[vofs + 3])
                      result.src_offset=(   val[vofs ].src_offset ) # kCASE position
                    }
                | kCASE            opt_termms case_body kEND
                    {
		      yTrace("primary: | kCASE opt_termms case_body kEND")
                      if val[vofs + 3]._equal?( :tEOF )
                        premature_eof( val[vofs ] )
                      end
                      result = new_case( nil, val[vofs + 2] )
                      result.src_offset=(   val[vofs ].src_offset ) # kCASE position
                    }
                | kCASE opt_termms kELSE comp_stamt kEND # TODO: need a test
                    {
		      yTrace("primary: | kCASE opt_termms kELSE comp_stamt kEND")
                      if val[vofs + 4]._equal?( :tEOF )
                        premature_eof( val[vofs ] )
                      end
                      result = new_case( nil, val[vofs + 3] )
                      result.src_offset=(   val[vofs ].src_offset ) # kCASE position
                    }
                | kFOR blck_var kIN
                    {
		      yTrace("primary: | kFOR blck_var kIN")
                      @lexer.cond_.push( true )
                      result = val[vofs]
                    }
                    expr_value do
                    {
		      yTrace("primary: kFOR ___ expr_value do")
                      @lexer.cond_.pop
                      result = val[vofs]
                    }
                    comp_stamt kEND
                    {
		      yTrace("primary: kFOR ___ comp_stamt kEND")
                      if val[vofs + 8]._equal?( :tEOF )
                        premature_eof( val[vofs ] )
                      end
                      result = new_for( val[vofs + 4], val[vofs + 1], val[vofs + 7])
                      result.src_offset=( val[vofs ].src_offset ) # kFOR position
                    }
                | kCLASS cpath superclass
                    {
		      yTrace("primary: | kCLASS cpath superclass")
                      # @comments.push( @lexer.comments_ )
                      if (@in_def || @in_single > 0) then
raise SyntaxError, "class definition in method body, near line #{@lexer.lineno_}\n cannot continue parsing."
                      end
                      @env.extend( false, :module )
                      result = val[vofs]
                    }
                    body_stamt kEND
                    {
		      yTrace("primary: | kCLASS ___ body_stamt kEND")
                      result = new_class( val, vofs )
                      @env.unextend
                    }
                | kCLASS tLSHFT expr
                    {
		      yTrace("primary: | kCLASS tLSHFT expr")
                      result = @in_def
                      @in_def = false
                    }
                    t_erm
                    {
		      yTrace("primary | kCLASS ___ t_erm")
                      result = @in_single
                      @in_single = 0
                      @env.extend( false, :module )
                    }
                    body_stamt kEND
                    {
		      yTrace("primary  | kCLASS ___ body_stamt kEND")
                      result = new_sclass(val, vofs )
                      @env.unextend
                    }
                | kMODULE cpath
                    {
		      yTrace("primary: | kMODULE cpath")
                      # @comments.push( @lexer.comments_ )
                      if   @in_def or @in_single > 0
                        raise SyntaxError,  "module definition in method body" 
                      end
                      @env.extend( false, :module )
                      result = val[vofs]
                    }
                    body_stamt kEND
                    {
		      yTrace("primary: | kMODULE ___ body_stamt kEND")
                      result = new_module( val, vofs )
                      @env.unextend
                    }
                | kDEF fname
                    {
		      yTrace("primary: | kDEF fname")
                      lx = @lexer
                      # @comments.push( lx.comments_ )
                      @in_def = true
                      @env.extend( false, :def )
                      result =  -907  # dummy result, replaces [line, beginOfLine]
                    }
                    f_arglist body_stamt kEND
                    {
		      yTrace("primary: | kDEF ___ f_arglist body_stamt kEND")
                      result = new_defn( val , vofs )
                      @env.unextend
                      @in_def = false
                    }
                | kDEF singleton dot_or_colon
                    {
		      yTrace("primary: | kDEF singleton dot_or_colon")
                      lx = @lexer
                      # @comments.push( lx.comments_ )
                      lx.lex_state=( Expr_fname )
                      result = val[vofs]
                    }
                    fname
                    {
		      yTrace("primary: | kDEF ___ fname")
                      @in_single += 1
                      @env.extend( false, :def )
                      @lexer.lex_state=( Expr_end )# force for args
                      result = val[vofs]
                    }
                    f_arglist body_stamt kEND
                    {
		      yTrace("primary: | kDEF ___ f_arglist body_stamt kEND")
                      result = new_defs( val , vofs )

                      @env.unextend
                      @in_single -= 1
                    }
                | kBREAK
                    {
		      yTrace("primary: | kBREAK")
                      result = RubyBreakNode.s(nil) # s(:break)
                      result.src_offset=( val[vofs ].src_offset ) #  of the kBREAK
                    }
                | kNEXT
                    {
		      yTrace("primary: | kNEXT")
                      result = RubyNextNode.s(nil) #  s(:next)
                      result.src_offset=( val[vofs ].src_offset ) #  of the kNEXT
                    }
                | kREDO
                    {
		      yTrace("primary: | kREDO")
                      result = RubyRedoNode._new # s(:redo)
                      result.src_offset=( val[vofs ].src_offset ) #  of the kREDO
                    }
                | kRETRY
                    {
		      yTrace("primary: | kRETRY")
                      result = RubyRetryNode._new # s(:retry)
                      result.src_offset=( val[vofs ].src_offset ) #  of the kRETRY
                    }

   primary_value: primary
                    {
		      yTrace("primary_value: primary")
                      result = value_expr(val[vofs ])
                    }

            then: t_erm
                | tCOLON
                | kTHEN
                | t_erm kTHEN

              do: t_erm
                | tCOLON
                | kDO_COND

         if_tail: opt_else
                | kELSIF expr_value then comp_stamt if_tail
                    {
		      yTrace("if_tail: opt_else| kELSIF___if_tail ")
                      result = RubyIfNode.s(val[vofs + 1], val[vofs + 3], val[vofs + 4]) # s(:if )
                    }

        opt_else: none               Y_TRACE_val_vofs("opt_else: none")
                | kELSE comp_stamt
                    {
		      yTrace("opt_else: | kELSE comp_stamt")
                      result = val[vofs + 1]
                    }

       blck_var: lhs           Y_TRACE_val_vofs("blck_var: lhs")
                | mLhs  
                    {
                      yTrace("blck_var: | mLhs")
                      # val_[0].delete_at 1 if val[0][1].nil? # HACK
                      # Maglev, do nothing for now
                      result = val[vofs]
                    }

   opt_block_var: none              Y_TRACE_val_vofs("opt_block_var: none") 
                | tPIPE tPIPE
                    {
		      yTrace("opt_block_var: | tPIPE tPIPE")
ifdef(`PARSER_DEBUG', `
                      unless @env.in_block_params ; nil.pause ; end
')
                      result = 0
                    }
                | tOROP
                    {
		      yTrace("opt_block_var: | tOROP")
ifdef(`PARSER_DEBUG', `
                      unless @env.in_block_params ; nil.pause ; end
')
                      result = 0
                    }
                | tPIPE blck_var tPIPE
                    {
		      yTrace("opt_block_var: | tPIPE blck_var tPIPE")
ifdef(`PARSER_DEBUG', `
                      unless @env.in_block_params ; nil.pause ; end
')

                      result = val[vofs + 1]   
                    }

        do_block: kDO_BLOCK
                    {
		      yTrace("do_block: kDO_BLOCK")
		      @env.extend( true , nil ) # (:dynamic)
                      @env.in_block_params=(true)
                      result = val[vofs]
                    }
                    opt_block_var
                    {
		      yTrace("do_block: ___ opt_block_var")
                      result = @env.dynamic_keys
                      @env.in_block_params=(false)
                    }
                    comp_stamt kEND
                    {
		      yTrace("do_block: ___ comp_stamt kEND")
                      if val[vofs + 5]._equal?( :tEOF )
                        premature_eof( val[vofs] )  # of kDO
                      end
                      vars   = val[vofs + 2]
                      body   = val[vofs + 4]
                      result = new_iter(vars, body)
                      @env.unextend
                    }

      block_call: command do_block
                    {
		      yTrace("block_call: command do_block")
                      v_zero = val[vofs ]
                      if v_zero._equal?(nil)
                        # ok
                      elsif v_zero.class._equal?(RubyBlockPassNode) 
                        raise SyntaxError, "Both block arg and actual block given." 
                      end
                      iter = val[vofs + 1]
                      iter.call=(v_zero)
                      result = iter
                    }
                | block_call tDOT operation2 opt_paren_args
                    {
		      yTrace("block_call: | block_call tDOT operation2 opt_paren_args")
                      result = new_call(val[vofs ], val[vofs + 2], val[vofs + 3])
                    }
                | block_call tCOLON2 operation2 opt_paren_args
                    {
		      yTrace("block_call: block_call tCOLON2 operation2 opt_paren_args")
                      result = new_call(val[vofs ], val[vofs + 2], val[vofs + 3])
                    }

     method_call: operation paren_args
                    {
		      yTrace("method_call: operation  paren_args")
                      result = new_fcall( val[vofs ], val[vofs + 1] )
                    }
                | primary_value tDOT operation2 opt_paren_args
                    {
		      yTrace("method_call: | primary_value tDOT operation2 opt_paren_args")
                      result = new_call(val[vofs ], val[vofs + 2], val[vofs + 3] )
                    }
                | primary_value tCOLON2 operation2 paren_args
                    {
		      yTrace("method_call: | primary_value tCOLON2 operation2 paren_args")
                      result = new_call(val[vofs ], val[vofs + 2], val[vofs + 3] )
                    }
                | primary_value tCOLON2 operation3
                    {
		      yTrace("method_call: | primary_value tCOLON2 operation3")
                      result = new_vcall( val[vofs ], val[vofs + 2] )
                    }
                | kSUPER paren_args
                    {
		      yTrace("method_call: | kSUPER paren_args")
                      result = new_super( val , vofs )
                    }
                | kSUPER
                    {
		      yTrace("method_call: | kSUPER")
                      result = RubyZSuperNode._new # s(:zsuper)
                      result.src_offset=( val[vofs].src_offset ) # of the kSUPER
                    }

     brace_blck: tLCURLY
                    {
		      yTrace("brace_blck: tLCURLY")
		      @env.extend( true , nil ) # (:dynamic)
                      @env.in_block_params=(true)
                      result = -909 # @lexer.lineno_
                    }
                    opt_block_var
                    {
		      yTrace("brace_blck: tLCURLY ___ opt_block_var")
                      result = @env.dynamic_keys
                      @env.in_block_params=(false)
                    }
                    comp_stamt tRCURLY
                    {
		      yTrace("brace_blck: tLCURLY ___ comp_stamt tRCURLY")
                      # REFACTOR
                      args   = val[vofs + 2]
                      body   = val[vofs + 4]
                      result = new_iter(args, body)
                      @env.unextend
                    }
                | kDO
                    {
		      yTrace("brace_blck: | kDO")
		      @env.extend( true , nil ) # (:dynamic)
                      @env.in_block_params=(true)
                      result = -910 # @lexer.lineno_      
                    }
                 opt_block_var
                    {
		      yTrace("brace_blck: | kDO ___ opt_block_var")
                      result = @env.dynamic_keys
                      @env.in_block_params=(false)
                    }
                    comp_stamt kEND
                    {
		      yTrace("brace_blck: | kDO ___ comp_stamt kEND")
                      if val[vofs + 5]._equal?( :tEOF )
                        premature_eof( val[vofs] )
                      end
                      args = val[vofs + 2]
                      body = val[vofs + 4]
                      result = new_iter(args, body)
                      @env.unextend
                    }

       case_body: kWHEN when_args then comp_stamt cases
                    {
                      yTrace("case_body: kWHEN when_args then comp_stamt cases")
                      result = RubyWhenNode.s( val[vofs + 1], val[vofs + 3], val[vofs + 4])  # s(:when )
                      result.src_offset=(   val[vofs ].src_offset ) # kWHEN position
                    }

       when_args: args
                | args tCOMMA tSTAR arg_value
                    {
                      yTrace("when_args: args | args tCOMMA tSTAR arg_value")
                      wh = RubyWhenNode.s(val[vofs + 3], nil, nil)
                      wh.src_offset=(   val[vofs + 2].src_offset ) # tSTAR position
                      result = self.list_append( val[vofs ], wh )
                    }
                | tSTAR arg_value
                    {
		      yTrace("when_args: | tSTAR arg_value")
                      # result = s(:array, s(:when, val_[1], nil))
                      wh = RubyWhenNode.s( val[vofs + 1], nil, nil)
                      wh.src_offset=(   val[vofs ].src_offset ) # tSTAR position
                      result = RubyRpCallArgs.s( wh )
                    }

           cases: opt_else | case_body

      opt_rescue: kRESCUE exc_list exc_var then comp_stamt opt_rescue
                    {
	              yTrace("opt_rescue: kRESCUE exc_list exc_var then comp_stamt opt_rescue")
                      # klasses, var, body, rest = val_[1], val_[2], val_[4], val_[5]
                      # klasses ||= s(:array )  # Maglev not used
                      klasses = val[vofs + 1]   # ok if nil
                      var = val[vofs + 2]
                      body = val[vofs + 4]
                      rest = val[vofs + 5] 
                      if var 
                        r_hs = RubyGlobalVarNode.s( :"$!" )  # s(:gvar )
                        asgn = node_assign(var, r_hs )
                        if body._equal?(nil)
                          body = RubyBlockNode.s( [ asgn ] )
                        else
                          body = body.prepend_to_block( asgn )
                        end
                      end   
                      result = RubyRescueBodyNode.s(klasses, body, rest)   # s(:resbody )
                      result.src_offset=( val[vofs ].src_offset )   # kRESCUE position
                    }
                |
                    {
		      yTrace("opt_rescue: |")
                      result = nil
                    }

        exc_list: arg_value
                    {
	              yTrace("exc_list: arg_value")
                      result = RubyArrayNode.s( val[vofs ])  # s(:array )
                    }
                | mrhs     Y_TRACE_val_vofs("exc_list: | mrhs")
                | none     Y_TRACE_val_vofs("exc_list: | none")

         exc_var: tASSOC lhs
                    {
		      yTrace("exc_var: tASSOC lhs")
                      result = val[vofs + 1]
                    }
                | none       Y_TRACE_val_vofs("exc_var: | none")

      opt_ensure: kENSURE comp_stamt
                    {
		      yTrace("opt_ensure: kENSURE comp_stamt")
                      v_one = val[vofs + 1]
                      if v_one._equal?(nil)
                        v_one = RubyNilNode._new # s(:nil)
                      end
                      result = RubyEnsureNode.s( v_one )
                      result.src_offset=( val[vofs ].src_offset ) # kENSURE position
                    }
                | none         Y_TRACE_val_vofs("opt_ensure: | none")

         literal: numeric { 
		    yTrace("literal: numeric")
		    result = RubyAbstractNumberNode.s( val[vofs ])  # s(:lit )
		    }
                | symbol  { 
		    yTrace("literal: | symbol")
		    result = RubySymbolNode.s( val[vofs ]) # s(:lit )
		    }  
                | dsym    Y_TRACE_val_vofs("literal: dsym")

         strings: string
                    {
		      yTrace("strings: string")
                      # val_[0] = s(:dstr, val[0].value) if val[0][0] == :evstr 
                      # result = val_[0]
                      v_zero = val[vofs ] 
                      if v_zero.class._equal?(RubyEvStrNode)
                        result = RubyDStrNode.s( [ v_zero.evStrBody ] )
                      else
                        result = v_zero
                      end 
                    }

          string: string1         Y_TRACE_val_vofs("string: string1 ")
                | string string1
                    {
		      yTrace("string: | string string1")
                      result = self.literal_concat( val[vofs ], val[vofs + 1])  
                    }

         string1: tSTRING_BEG string_contents tSTRING_END
                    {
		      yTrace("string1: tSTRING_BEG string_contents tSTRING_END")
                      result = val[vofs + 1]
                    }
                | t_STRING
                    {
		      yTrace("string1: | t_STRING")
                      result = RubyStrNode.s( val[vofs ])  # s(:str )
                    }

         xstring: tXSTRING_BEG xstring_contents tSTRING_END
                    {
		      yTrace("xstring: tXSTRING_BEG xstring_contents tSTRING_END")
                      result = new_xstring( val[vofs + 1])
                      result.src_offset=( val[vofs ].src_offset ) # tXSTRING_BEG position
                    }

          regexp: tREGEXP_BEG xstring_contents tREGEXP_END
                    {
		      yTrace("regexp: tREGEXP_BEG xstring_contents tREGEXP_END")
                      result = new_regexp(val, vofs)
                    }

           words: tWORDS_BEG tSPACE tSTRING_END
                    {
		      yTrace("words: tWORDS_BEG tSPACE tSTRING_END")
                      result = RubyArrayNode._new # s(:array)
                    }
                | tWORDS_BEG word_list tSTRING_END
                    {
		      yTrace("words: | tWORDS_BEG word_list tSTRING_END")
                      result = val[vofs + 1]
                    }

       word_list: none
                    {
		      yTrace("word_list: none")
                      result = RubyArrayNode._new # s(:array)
                    }
                | word_list word tSPACE
                    {
		      yTrace("word_list: | word_list word tSPACE")
                      # word = val_[1][0] == :evstr ? s(:dstr, "", val[1]) : val[1] #
                      # result = val_[0] << word
                      v_one = val[vofs + 1]
                      if v_one.class._equal?(RubyEvStrNode)
                        word = RubyDStrNode.s([ RubyStrNode.s('') , v_one ])
                      else
                        word = v_one
                      end
                      result = val[vofs ].append( word)  # v[0] should be a RubyArrayNode
                    }

            word: string_content         Y_TRACE_val_vofs("word: string_content")
                | word string_content
                    {
		      yTrace("word: | word string_content")
                      result = self.literal_concat( val[vofs ], val[vofs + 1])
                    }

          awords: tAWORDS_BEG tSPACE tSTRING_END
                    {
		      yTrace("awords: tAWORDS_BEG tSPACE tSTRING_END")
                      result = RubyArrayNode._new # s(:array)
                    }
                | tAWORDS_BEG qword_list tSTRING_END
                    {
		      yTrace("awords: | tAWORDS_BEG qword_list tSTRING_END")
                      result = val[vofs + 1]
                    }

      qword_list: none
                    {
		      yTrace("qword_list: none")
                      result = RubyArrayNode._new # s(:array)
                    }
                | qword_list tSTRING_CONTENT tSPACE
                    {
		      yTrace("qword_list: | qword_list tSTRING_CONTENT tSPACE")
                      # result = val_[0] << s(:str, val_[1]) # assume val[0] is ArrayNode 
                      result = val[vofs ].append( RubyStrNode.s(val[vofs + 1]))
                    }

 string_contents: none
                    {
			yTrace("string_contents: none")
                      	# result = s(:str, "")
			result = RubyStrNode.s( "")
                    }
                | string_contents string_content
                    {
		      yTrace("string_contents: | string_contents string_content")
                      result = self.literal_concat(val[vofs ], val[vofs + 1])
                    }

xstring_contents: none
                    {
		      yTrace("xstring_contents: none")
                      result = nil
                    }
                | xstring_contents string_content
                    {
		      yTrace("xstring_contents: | xstring_contents string_content")
                      result = self.literal_concat(val[vofs ], val[vofs + 1])
                    }

  string_content: tSTRING_CONTENT
                    {
		      yTrace("string_content: tSTRING_CONTENT")
                      # result = s(:str, val_[0])
		      result = RubyStrNode.s( val[vofs ])
                    }
                | tSTRING_DVAR
                    {
		      yTrace("string_content: | tSTRING_DVAR")
                      lx = @lexer
                      result = lx.lex_strTerm_
                      lx.lex_strTerm=( nil )
                      lx.lex_state=( Expr_beg )
                    }
                    string_dvar
                    {
		      yTrace("string_content: | tSTRING_DVAR ___ string_dvar")
                      # result = s(:evstr, val_[2]) 
                      @lexer.lex_strTerm=( val[vofs + 1])
                      result = RubyEvStrNode.s( val[vofs + 2] )
                    }
                | tSTRING_DBEG
                    {
		      yTrace("string_content: | tSTRING_DBEG")
                      lx = @lexer
                      result = lx.lex_strTerm_
                      lx.lex_strTerm=( nil )
                      lx.lex_state=( Expr_beg )
                      lx.cond_.push( false)
                      lx.cmdarg_.push( false)
                    }
                    comp_stamt tRCURLY
                    {
		      yTrace("string_content: | tSTRING_DBEG ___ comp_stamt tRCURLY")
                      lx = @lexer
                      lx.lex_strTerm=( val[vofs + 1] )
                      lx.cond_.lexpop
                      lx.cmdarg_.lexpop

                      v_two = val[vofs + 2] 
                      if v_two._equal?(nil) 
                        result = RubyEvStrNode.s(nil) #  s(:evstr ) 
                      else 
                        knd = v_two.str_dstr_evstr_kind  # MNU here if "unknown rescue body"
                        if knd._equal?(nil) 
                           result = RubyEvStrNode.s(v_two)
                        else
                           result = v_two  # v_two is one of  :str :dstr: evstr
                        end
                      end
                    }

     string_dvar: tGVAR { 
		          yTrace("string_dvar: tGVAR")
		          # result = s(:gvar, val_[0].to_sym)   
			  result = RubyGlobalVarNode.s( val[vofs ].symval )
			}
                | tIVAR { 
			  yTrace("string_dvar: | tIVAR")
		          # result = s(:ivar, val_[0].to_sym) 
			  result = RubyInstVarNode.s( val[vofs ].symval )
			}
                | tCVAR { 
			  yTrace("string_dvar: | tCVAR")
	                  # result = s(:cvar, val_[0].to_sym) 
			  result = RubyClassVarNode.s( val[vofs ].symval)
			}
                | backref    Y_TRACE_val_vofs("string_dvar: | backref")


          symbol: tSYMBEG sym
                    {
		      yTrace("symbol: tSYMBEG sym")
                      @lexer.lex_state=( Expr_end )
                      result = val[vofs + 1].symval  # expect an RpNameToken
                    }
                | tSYMBOL
                    {
		      yTrace("symbol: | tSYMBOL")
                      result =  val[vofs ].__as_symbol 
                    }

             sym: fname | tIVAR | tGVAR | tCVAR

            dsym: tSYMBEG xstring_contents tSTRING_END
                    {
		      yTrace("dsym: tSYMBEG xstring_contents tSTRING_END")
                      @lexer.lex_state=( Expr_end )
                      v_one = val[vofs + 1]

		      v_cls = v_one.class
		      if v_cls._equal?(RubyDStrNode)  # convert :dstr to :dsym
		        result =v_one.asDSymbolNode 
                      elsif v_cls._equal?(RubyStrNode) # convert :str to :sym
                        str = v_one.strNodeValue
			result = RubySymbolNode.s( self.string_to_symbol(str) )
                      elsif v_one._equal?( nil) 
                        yyerror "empty symbol literal" 
                        result = nil
                      elsif v_cls._equal?(RubyEvStrNode)
                        result = RubyDSymbolNode.s([ RubyStrNode.s('') , v_one ])
                        # result = s(:dsym, "", result)
                      else
			internal_error("unimplemented dsym conversion")
                        result = nil
                      end
                    }

         numeric: tINTEGER   Y_TRACE_val_vofs("numeric: tINTEGER ")
                | tFLOAT     Y_TRACE_val_vofs("numeric: tFLOAT ")
                | tUMINUS_NUM tINTEGER =tLOWEST
                    {
		      yTrace("numeric: ___ tUMINUS_NUM tINTEGER")
                      result = val[vofs + 1] * -1 # TODOryan: pt_testcase
                    }
                | tUMINUS_NUM tFLOAT   =tLOWEST
                    {
		      yTrace("numeric: ___ tUMINUS_NUM tFLOAT")
                      result = val[vofs + 1] * -1 # TODOryan: pt_testcase
                    }

        variable: tIDENTIFIER  Y_TRACE_val_vofs("variable: tIDENTIFIER")
                | tIVAR        Y_TRACE_val_vofs("variable: | tIVAR")
                | tGVAR        Y_TRACE_val_vofs("variable: | tGVAR")
                | tCONSTANT    Y_TRACE_val_vofs("variable: | tCONSTANT")
                | tCVAR        Y_TRACE_val_vofs("variable: | tCVAR")
                | kNIL      {  
 			      yTrace("variable: | kNIL")
                              result = :nil      
                            }
                | kSELF     {  
			      yTrace("variable: |kSELF")
			      result = :self     
                            }
                | kTRUE     {  
			      yTrace("variable: |kTRUE")
			      result = :true     
                            }
                | kFALSE    {  
			      yTrace("variable: |kFALSE")
			      result = :false    
                            }
                | k__FILE__ { 
			      yTrace("variable: |k__FILE__")
			      result = :__FILE__ 
                            }
                | k__LINE__ { 
			      yTrace("variable: |k__LINE__")
			      result =  RpNameToken.new( :__LINE__ ,  @lexer.line_num_)  
                            }

         var_ref: variable
                    {
		      yTrace("var_ref: variable")
                      result = self.gettable( val[vofs ])
                    }

         varLhs: variable
                    {
		      yTrace("varLhs: variable")
                      result = self.assignable(val[vofs ], nil)
                    }

         backref: tNTH_REF  { 
			      yTrace("backref: tNTH_REF")
	                      # result = s(:nth_ref,  val_[0]) 
			      result = RubyNthRefNode.s(val[vofs ])
			    }
                | tBACK_REF { 
			      yTrace("backref: | tBACK_REF")
			      # result = s(:back_ref, val_[0])
			      result = RubyBackRefNode.s( val[vofs ] )
			    }

      superclass: t_erm
                    {
		      yTrace("superclass: t_erm")
                      result = nil
                    }
                | tLT
                    {
		      yTrace("superclass: | tLT")
                      @lexer.lex_state=( Expr_beg )
                      result = val[vofs]
                    }
                    expr_value t_erm
                    {
		      yTrace("superclass: | tLT ___ expr_value t_erm")
                      result = val[vofs + 2]
                    }
                | error t_erm
                    {
		      yTrace("superclass: | error t_erm")
                      leave_error_recovery_mode()
                      result = nil
                    }

       f_arglist: tLPAREN2 f_args opt_nl tRPAREN
                    {
		      yTrace("f_arglist: tLPAREN2 f_args opt_nl tRPAREN")
                      result = val[vofs + 1]
                      @lexer.lex_state=( Expr_beg )
                    }
                | f_args t_erm 
 		    {
                      yTrace("f_arglist: | f_args t_erm")
                      result = val[vofs ]
                    }


          f_args: f_arg tCOMMA f_optarg tCOMMA f_rest_arg opt_f_block_arg
                    {
		      yTrace("f_args: f_arg tCOMMA f_optarg tCOMMA f_rest_arg opt_f_block_arg")
                      # result = args( val_[0], val_[2], val_[4], val_[5])
                      result = val[vofs ]
                      result.add_optional_arg( val[vofs + 2] )
                      result.add_star_arg( val[vofs + 4] )
                      result.add_block_arg( val[vofs + 5] )
                    }
                | f_arg tCOMMA f_optarg                opt_f_block_arg
                    {
		      yTrace("f_args: | f_arg tCOMMA f_optarg  opt_f_block_arg")
                      # result = args( val_[0], val_[2],    nil, val_[3])
                      result = val[vofs ] 
                      result.add_optional_arg( val[vofs + 2] )
                      result.add_block_arg( val[vofs + 3] )
                    }
                | f_arg tCOMMA              f_rest_arg opt_f_block_arg
                    {
		      yTrace("f_args: | f_arg tCOMMA  f_rest_arg opt_f_block_arg")
                      # result = args( val_[0],    nil, val_[2], val_[3])
                      result = val[vofs ] 
                      result.add_star_arg( val[vofs + 2] )
                      result.add_block_arg( val[vofs + 3] )
                    }
                | f_arg                             opt_f_block_arg
                    {
		      yTrace("f_args: | f_arg  opt_f_block_arg")
                      # result = args( val_[0],    nil,    nil, val_[1])
                      result = val[vofs ] 
                      result.add_block_arg( val[vofs + 1] )
                    }
                |           f_optarg tCOMMA f_rest_arg opt_f_block_arg
                    {
		      yTrace("f_args: | f_optarg tCOMMA f_rest_arg opt_f_block_arg")
                      # result = args(    nil, val_[0], val_[2], val_[3])
                      result = RubyArgsNode._new
                      result.add_optional_arg(val[vofs ] )
                      result.add_star_arg( val[vofs + 2] )
                      result.add_block_arg( val[vofs + 3] )
                    }
                |           f_optarg                opt_f_block_arg
                    {
		      yTrace("f_args: |  f_optarg  opt_f_block_arg")
                      # result = args(    nil, val_[0],    nil, val_[1])
                      result = RubyArgsNode._new
                      result.add_optional_arg(val[vofs ])
                      result.add_block_arg( val[vofs + 1] )

                    }
                |                        f_rest_arg opt_f_block_arg
                    {
		      yTrace("f_args: | f_rest_arg opt_f_block_arg")
                      # result = args(    nil,    nil, val_[0], val_[1])
                      result = RubyArgsNode._new
                      result.add_star_arg( val[vofs ] )
                      result.add_block_arg( val[vofs + 1] )
                    }
                |                                       f_blck_arg
                    {
		      yTrace("f_args: |  f_blck_arg")
                      # result = args(    nil,    nil,    nil, val_[0])
                      result = RubyArgsNode._new
                      result.add_block_arg( val[vofs ] )
                    }
                |
                    {
		      yTrace("f_args: | <nothing>")
                      #result = args(    nil,    nil,    nil,    nil)
                      result = RubyArgsNode._new
                    }

      f_norm_arg: tCONSTANT
                    {
		      yTrace("f_norm_arg: tCONSTANT")
                      raise SyntaxError, "formal argument cannot be a constant: #{val[vofs ]}"
                      result = val[vofs]
                    }
                | tIVAR
                    {
		      yTrace("f_norm_arg: | tIVAR")
                      raise SyntaxError, "formal argument cannot be an instance variable"
                      result = val[vofs]
                    }
                | tCVAR
                    {
		      yTrace("f_norm_arg: | tCVAR")
                      raise SyntaxError, "formal argument cannot be a class variable"
                      result = val[vofs]
                    }
                | tIDENTIFIER
                    {
		      yTrace("f_norm_arg: | tIDENTIFIER")
                      v_zero = val[vofs ]  # val_[0] will be a RpNameToken
                      @env[ v_zero.symval ] = :lvar
                      result = v_zero
                    }

           f_arg: f_norm_arg
                    {
		      yTrace("f_arg: f_norm_arg")
                      # result = s(:args)
                      # result << val_[0].to_sym
                      result = RubyArgsNode._new
                      result.add_arg( val[vofs ].symval )
                    }
                | f_arg tCOMMA f_norm_arg
                    {
		      yTrace("f_arg: | f_arg tCOMMA f_norm_arg")
                      result = val[vofs ]
                      result.add_arg( val[vofs + 2].symval )
                    }

           f_opt: tIDENTIFIER tEQL arg_value
                    {
		      yTrace("f_opt: tIDENTIFIER tEQL arg_value")
                      result = self.assignable(val[vofs ], val[vofs + 2])
                      # TODO: detect duplicate names  ??
                    }

        f_optarg: f_opt
                    {
		      yTrace("f_optarg: f_opt")
                      result = RubyBlockNode.s( [ val[vofs ] ] ) # s(:block )
                    }
                | f_optarg tCOMMA f_opt
                    {
		      yTrace("f_optarg: | f_optarg tCOMMA f_opt")
                      result = val[vofs ] # a RubyBlockNode
                      result.append_to_block( val[vofs + 2] )
                    }

    restarg_mark: tSTAR2 | tSTAR

      f_rest_arg: restarg_mark tIDENTIFIER
                    {
		      yTrace("f_rest_arg: restarg_mark tIDENTIFIER")
                      # TODOryan: differs from parse.y - needs tests
                      name = val[vofs + 1].symval    # expect a RpNameToken
                      self.check_assignable( name ) # updates env
                      result = name   # MagLev, no prefixing of f_rest_arg with '*' 
                    }
                | restarg_mark
                    {
		      yTrace("f_rest_arg: | restarg_mark")
                      name = :"*"
                      @env[name] = :lvar
                      result = name
                    }

     blkarg_mark: tAMPER2 | tAMPER

     f_blck_arg: blkarg_mark tIDENTIFIER
                    {
		      yTrace("f_blck_arg: blkarg_mark tIDENTIFIER")
                      identifier = val[vofs + 1].symval

                      @env[identifier] = :lvar
                      # result = s(:block_arg, identifier.to_sym)
		      result = RubyBlockArgNode.s( identifier)
                    }

 opt_f_block_arg: tCOMMA f_blck_arg
                    {
		      yTrace("opt_f_block_arg: tCOMMA f_blck_arg")
                      result = val[vofs + 1]
                    }
                |
                    {
		      yTrace("opt_f_block_arg: | <nothing>")
                      result = nil
                    }

       singleton: var_ref    Y_TRACE_val_vofs("singleton: var_ref")
                | tLPAREN2
                    {
		      yTrace("singleton: | tLPAREN2")
                      @lexer.lex_state=( Expr_beg )
                      result = val[vofs]
                    }
                    expr opt_nl tRPAREN
                    {
		      yTrace("singleton: ___ expr opt_nl tRPAREN") 
                      result = val[vofs + 2]
		      if result._kind_of?(RubyAbstractLiteralNode)
                        yyerror "Can't define singleton method for literals." 
		      end
                    }

      assoc_list: none # [!nil]
                    {
		      yTrace("assoc_list: none")
                      result = RubyArrayNode._new # s(:array)
                    }
                | assocs trailer # [!nil]
                    {
                      yTrace("assoc_list: | assocs trailer")
                      result = val[vofs ]
                    }
                | args trailer
                    {
		      yTrace("assoc_list: | args trailer")
                      # size = val_[0].size
                      # if (size % 2 != 1) then # != 1 because of leading :array
                      v_zero = val[vofs ]
                      size = v_zero.arrayLength
                      unless (size & 1)._equal?(0)
                        yyerror "Odd number (#{size}) list for Hash. #{v_zero.inspect}"
                      end
                      result = v_zero
                    }

          assocs: assoc      Y_TRACE_val_vofs("assocs: assoc")
                | assocs tCOMMA assoc
                    {
                      yTrace("assocs: | assocs tCOMMA assoc")
                      list = val[vofs ].arrayDup  # dup a RubyArrayNode
                      v_two = val[vofs + 2]
                      list.appendAll(v_two) # expect v_two to be a RubyArrayNode
                      result = list
                    }

           assoc: arg_value tASSOC arg_value
                    {
		      yTrace("assoc: arg_value tASSOC arg_value")
                      result = RubyArrayNode.s( val[vofs ], val[vofs + 2]) # s(:array )
                    }

       operation: tIDENTIFIER | tCONSTANT | tFID
      operation2: tIDENTIFIER | tCONSTANT | tFID | op
      operation3: tIDENTIFIER | tFID | op
    dot_or_colon: tDOT | tCOLON2
       opt_termms:  | terms
          opt_nl:  | tNL
         trailer:  | tNL | tCOMMA

            t_erm: tSEMI 
                      {  
                        yTrace("t_erm: tSEMI")
                        leave_error_recovery_mode() 
                        result = val[vofs] 
                      }
                | tNL

           terms: t_erm    Y_TRACE_val_vofs("terms: t_erm ")
                | terms tSEMI 
                    {  
		      yTrace("terms: | terms tSEMI")
                      leave_error_recovery_mode() 
		      result = val[vofs] 
		    }

            none: {  
                    yTrace("none:")
		    result = nil  
		  }

 none_block_pass: {  
                    yTrace("none_block_pass:")
		    result = nil 
		  }

end

---- inner

require "kernel/parser/lexer.rb"

# Local Variables: **
# racc-token-length-max:14 **
# End: **
