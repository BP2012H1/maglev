# TODO:
#   need to ensure all data structures are released/free()d

module Psych
  # LibPsych wraps libparser.dylib.  libparser is a layer of support to
  # hide the complexity of libyaml with its deeply nested structs and
  # unions.  libparser is designed to pass into ruby just the items
  # required by Psych.
  class LibPsych
    extend FFI::Library
    ffi_lib '/Users/pmclain/GemStone/checkouts/git/src/experimental/yaml/c/libpsych.dylib'

    attach_function :next_event, [:pointer, :pointer], :void
    attach_function :create_parser_context, [], :pointer
    attach_function :create_event, [], :pointer

    ParserEventEnum = FFI::Enum.new([:no_event,
                                     :stream_start_event,
                                     :stream_end_event,
                                     :document_start_event,
                                     :document_end_event,
                                     :alias_event,
                                     :scalar_event,
                                     :sequence_start_event,
                                     :sequence_end_event,
                                     :mapping_start_event,
                                     :mapping_end_event,
                                     :parse_error_event],
                                    :parser_event_type_e)

    ParserEncodingEnum = FFI::Enum.new([:any, :utf8, :utf_16le, :utf_16be],
                                       :parser_character_encoding_e)

    class ParserEvent < FFI::Struct
      @@@
      struct do |s|
        s.name 'struct parser_event_s'
        s.include '/Users/pmclain/GemStone/checkouts/git/src/experimental/yaml/c/parser.h'
        s.field :type,          :int
        s.field :encoding,      :int

        s.field :version_major, :int
        s.field :version_minor, :int

        s.field :num_tags,       :int
        s.field :tag_directives, :pointer

        s.field :yaml_line,     :size_t
        s.field :yaml_column,   :size_t

        s.field :scalar,        :pointer  # char * of given length
        s.field :scalar_length, :long

        s.field :style,         :long
        s.field :anchor,        :string
        s.field :tag,           :string
        s.field :flag,          :uchar
      end
      @@@

      VERSION_FLAG  = 0x01;
      IMPLICIT_FLAG = 0x02;
      QUOTE_FLAG    = 0x04;

      def has_version?
        (self[:flag] & VERSION_FLAG) != 0
      end

      def implicit?
        (self[:flag] & IMPLICIT_FLAG) != 0
      end

      def quoted?
        (self[:flag] & QUOTE_FLAG) != 0
      end

      # TODO: Should we raise an exception if the event type isn't correct?
      # Or just return nil?
      def version
        self.has_version? ? nil : [self[:version_major,], self[:version_minor]]
      end

      def event_type
        Psych::LibPsych::ParserEventEnum[self[:type]]
      end

      def character_encoding
        case event_type
        when :stream_start_event
          Psych::LibPsych::ParserEncodingEnum[self[:encoding]]
        else
          nil
        end
      end

      def value
        :stub_value
      end

      def tag
        :stub_tag
      end

      def plain
        :stub_plain
      end

      def style
        :stub_style
      end

      def tag_directives
        num_tags = self[:num_tags]
        if num_tags < 0
          raise ArgumentError.new "num_tags (#{num_tags}) should be positive"
        end
        if num_tags == 0
          []
        else
          [:stub]  # RxINC
          # The parser library returns an array of strings: two strings
          # (prefix and handle) for each tag.  E.g., here is an array that
          # represents two tags:
          #
          #    [ "!",     "tag:gemstone.com,2009",
          #      "!foo!", "tag:foo.com,1832" ]
          #
# #          tag_ptr = self[:tag_directives].read_pointer
#           tag_dirs = self[:tag_directives]
#           strings = tag_dirs.get_array_of_string(0, 2*num_tags)
# #          tag_ptr = FFI::MemoryPointer.new
# #          tag_ptr.write_pointer(tag_dirs.read_pointer)

# #          tag_ptr = tag_dirs.read_pointer
# #          tag_ptr = FFI::MemoryPointer.new(tag_dirs.read_pointer)
# #          strings = tag_ptr.get_array_of_string(0, 2*num_tags)
#           result = []
#           tag = idx = 0
#           while (tag < num_tags)
#             res << [strings[idx], strings[idx + 1]]
#             idx += 2
#           end
#           result
        end
      end

      def anchor
        case event_type
        when :alias_event, :scalar_event, :sequence_start_event, :mapping_start_event
          :stub_anchor
        else
          :stub_not_implemented
        end
      end
    end
  end


  class Parser
    def parse(string, handler)
      c_parser = Psych::LibPsych.create_parser_context(string)
      c_event = Psych::LibPsych.create_event()
      done = false
      while not done
        Psych::LibPsych.next_event(c_parser, c_event)
        event = Psych::LibPsych::ParserEvent.new(c_event)

        case event.event_type
        when :no_event
          puts "#{self}: No Event"

        when :stream_start_event
          handler.start_stream( event.character_encoding )

        when :stream_end_event
          handler.end_stream
          done = true

        when :document_start_event
          handler.start_document( event.version,
                                  event.tag_directives,
                                  event.implicit? )

        when :document_end_event
          handler.end_document( event.implicit? )

        when :alias_event
          handler.alias( event.anchor )

        when :scalar_event
          # TODO: Need to associate the current encoding with
          #       the scalar string...
          #           rb_enc_associate_index(val, encoding);
          handler.scalar( event.value,
                          event.anchor,
                          event.tag,
                          event.plain,
                          event.quoted?,
                          event.style )

        when :sequence_start_event
          handler.start_sequence( event.anchor,
                                  event.tag,
                                  event.implicit?,
                                  event.style )

        when :sequence_end_event
          handler.end_sequence

        when :mapping_start_event
          handler.start_mapping( event.anchor,
                                 event.tag,
                                 event.implicit?,
                                 event.style )

        when :mapping_end_event
          handler.end_mapping

        when :parse_error_event
          puts "#{self}: ERROR"
          done = true
        else
          puts "#{self}: UNKNOWN EVENT"
          done = true
        end
      end
    end
  end
end
